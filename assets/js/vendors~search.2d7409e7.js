(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{285:function(e,t,s){"use strict";s.r(t),t.default=[{title:"uniapp之微信小程序适配",path:"/posts/uniapp-weixin.html",strippedContent:'## uni.getUserProfile  授权获取用户信息，由于该方法每次都会弹出授权弹窗而且只能在按钮点击后调用该方法，无法先请求判断用户是否已授权过，只能通过本地缓存判断来决定是否调用该方法  ``` js  uni.getUserProfile({    desc: \'登录\',    success: info => {      console.log(info.encryptedData, info.iv)    },    fail: err => {      console.log(err)    }  })  ```  ## uni.getFileSystemManager().readFile()  上传图片转base64  ``` js  uni.chooseImage({    sourceType: ["camera", "album"],    success: (res) => {      res.tempFilePaths.map(item => {        uni.getFileSystemManager().readFile({ //文件管理系统按照base64方式读取生成的图片          filePath: item, //选择图片返回的相对路径          encoding: \'base64\', //编码格式          success: file => { //成功的回调            console.log(file.data)          }        })      })    }  })  ```  ## uni.canvasToTempFilePath()  在生成海报时 canvas 中的 drawImage() 无法使用 qrcode 生成的 base64 格式二维码，就需要先将 qrcode 生成的二维码直接放到 canvas 上，再用 uni.canvasToTempFilePath() 转成文件路径  ``` vue  <template>    <canvas class="my-qrcode" style="width: 500px;height: 500px;" width="500px" height="500px" canvas-id="myQrcode" id="myQrcode"></canvas>  </template>  <script>  import QRCode from \'@/utils/weapp-qrcode.js\'  export default {    methods: {      shortUrlToQr(shortUrl) {        new QRCode(\'myQrcode\',{          text: shortUrl, // 生成二维码的文本          width: 500,          height: 500,          padding: 12, // 生成二维码四周自动留边宽度，不传入默认为0          correctLevel: QRCode.CorrectLevel.L, // 二维码可辨识度          callback: setTimeout(() => {            // 接下来就可以直接调用微信小程序的api保存到本地或者将这张二维码直接画在海报上面去，看各自需求            uni.canvasToTempFilePath({              canvasId: \'myQrcode\',              x: 0,              y: 0,              width: 500,              height: 500,              success(e) {                console.log(e.tempFilePath)              }            })          }, 500)        })      }    }  }  <\/script>  ```  ## Android、iOS 的适配  ### 时间格式  IOS系统只识别 " / " 不识别 " - "  ``` js  var date = "2019-8-14 10:03:45"    //解决  var newDate = new Date(date.replace(/-/g, \'/\'));  ```'},{title:"【学习笔记】之vue",path:"/posts/vue.html",strippedContent:"## 注册全局  `require.context(搜索的目录，是否还搜索其子目录，匹配文件的正则表达式)`  ### 注册全局组件  ``` js  // index.js  import Vue from 'vue'    // 获取该文件夹下所有 .vue 后缀的文件  const files = require.context('.', false, /\\.vue$/)  files.keys().forEach(key => {    // 注册为全局组件    Vue.component(files(key).default.name, files(key).default)  })  ```  ### 引入项目中所有的svg文件  ``` js  const requireContext = require.context('./svg', false, /\\.svg$/)  const requireAll = context => context.keys().map(context)  requireAll(requireContext)  ```  ### store模块化  ```  ├── store      ├── modules          └── index.js      └── index.js  ```  modules -> index.js  ``` js  const files = require.context('.', false, /\\.js$/)  const modules = {}    files.keys().forEach(key => {    if (key === './index.js') return    modules[key.replace(/(\\.\\/|\\.js)/g, '')] = files(key).default  })    export default modules  ```  store -> index.js  ``` js  import Vue from 'vue'  import Vuex from 'vuex'  import modules from './modules'  Vue.use(Vuex)    export default new Vuex.Store({    modules  })  ```  ## 父组件和子组件的使用  ### 传值  父组件：  ``` vue  <template>    <child      message=\"父组件的值\"      @handle-click=\"handleChange\"    />  </template>  <script>  import child from './components/child'  export default {    name: 'parent',    components: {      child    },    methods: {      handleChange (data) {        console.log(data)      }    }  }  <\/script>  ```  子组件：  ``` vue  <template>    <h1>这是子组件</h1>    <div>{{ message }}</div>    <button      :size=\"btnSize\"      @click=\"handleClick\"    >      向父组件传值    </button>  </template>  <script>  export default {    name: child,    props: {      message: {        type: String,        default: null      },      btnSize: {        // 按钮尺寸        type: String,        default: null,        validator: value => {          return ['medium', 'small', 'mini'].indexOf(value) !== -1        }      }    },    methods: {      /**        * @description 函数描述的 必填        * @param id {Number} 传入需要获取名称的人物id 参数必填        * @return {String} 返回的姓名 返回值必填，空为void        * @author shi 2015/07/21 作者可选        * @version 1.1.0 可以不写 版本可选        * @example 示例代码，可选        */      handleClick () {        this.$emit('handle-click', '子组件的值')      }    }  }  <\/script>  ```  ### 双向绑定  父组件：  ``` vue  <template>    <child v-model=\"parentMsg\" />  </template>  <script>  import child from './components/child'  export default {    name: 'parent',    components: {      child    },    data {      return {        parentMsg: '父组件的model值'      }    }  }  <\/script>  ```  子组件：  ``` vue  <template>    <input      type=\"text\"      v-model='message'    />  </template>  <script>  export default {    name: child,    computed: {      message: {        get () {          return this.value        },        set (val) {          this.$emit('input', val)        }      }    },    props: {      value: {        // v-model 绑定的值        type: String,        default: null      }    }  }  <\/script>  ```  ### .sync使用  > .sync修饰符作为一个语法糖，他会扩展为一个自动更新父组件属性的v-on监听器    父组件：  ``` vue  <template>    <child :visible.sync=\"dialogVisible\" />  </template>  <script>  import child from './components/child'  export default {    name: 'parent',    components: {      child    },    data {      return {        dialogVisible: true      }    }  }  <\/script>  ```  子组件：  ``` vue  <template>    <el-dialog      title=\"弹窗\"      :visible.sync=\"dialogVisible\"    >      <span>这是一段信息</span>    </el-dialog>  </template>  <script>  export default {    name: child,    computed: {      dialogVisible: {        get () {          return this.visible        },        set (val) {          this.$emit('update:visible', val)        }      }    },    props: {      visible: {        // .sync 绑定的值        type: Boolean,        default: false      }    }  }  <\/script>  ```  ### ref使用  > 注意：需在 dom 元素加载完成后 $refs 才能获取到该元素，所以需要判断 $refs 是否获取到元素才可继续，否则会报错    父组件：  ``` vue  <template>    <child ref=\"child\" />    <Button      type=\"primary\"      @click=\"prentClick\"    >      点击调用子组件方法    </Button>  </template>  <script>  import child from './components/child'  export default {    name: 'parent',    components: {      child    },    data {      return {        parentMsg: '父组件的属性'      }    },    methods: {      prentMethod () {        console.log('父组件的方法')      },      prentClick () {        this.$refs.child.childMethod() // 调用子组件的方法        console.log(this.$refs.child.childMsg) // 获取子组件的属性      },      // 获取子组件的ref      getChildRef () {        const thisRef = this.$refs.child        if (thisRef) {          const tableRef = thisRef.$refs.ehTable          if (tableRef) {            ...          }        }      }    }  }  <\/script>  ```  子组件：  ``` vue  <template>    <el-table ref=\"ehTable\" />    <Button      type=\"primary\"      @click=\"childClick\"    >      点击调用父组件方法    </Button>  </template>  <script>  export default {    name: child,    data {      return {        childMsg: '子组件的属性'      }    },    methods: {      childMethod () {        console.log('子组件的方法')      },      childClick () {        this.$parent.prentMethod() // 调用父组件的方法        console.log(this.$parent.parentMsg) // 获取父组件的属性      }    }  }  <\/script>  ```  ## 兄弟组件传值  在main.js注册一个全局bus：  ``` js  Vue.prototype.bus = new Vue()  ```  兄弟组件A向组件B传值  组件A:  ``` vue  <template>    <Button      type=\"primary\"      @click=\"sendClick\"    >      发布    </Button>  </template>  <script>  export default {    name: 'A',    data() {      return {        aMsg: '兄弟组件A的属性'      }    },    methods: {      sendClick () {        // 发布        this.bus.$emit('sendBybus', this.aMsg)      }    }  }  <\/script>  ```  组件B:  ``` vue  <template>    {{bMsg}}  </template>  <script>  export default {    name: 'B',    data() {      return {        bMsg: '兄弟组件B的属性'      }    },    methods: {      sendClick () {        // 订阅        this.bus.$on('sendBybus', data => {          console.log(data)          this.bMsg = data        })      }    }  }  <\/script>  ```  ## DOM的异步更新  ``` html  <div>    <span>      {{index}}    </span>    <button @click=\"handleChange\">      点击    </button>  </div>  ```  ### nextTick  ``` js  handleChange () {    this.$nextTick(() => {      this.index++    })  }  ```  ### forceUpdate  ``` js  handleChange () {    this.index++    this.$forceUpdate()  }  ```  ## vue多项目配置  ### 安装      npm install cross-env  ### 配置  在`package.json`文件配置变量  ``` js  \"scripts\": {    \"serve\": \"vue-cli-service serve\",    \"serve:stage\": \"cross-env VUE_APP_PREFIX=stage vue-cli-service serve\"    \"build\": \"vue-cli-service build\",    \"build:stage\": \"cross-env VUE_APP_PREFIX=stage vue-cli-service build\",    \"lint\": \"vue-cli-service lint\"  },  ```  自定义一个`cross-env`变量`VUE_APP_PREFIX`，在项目中接收到变量，然后通过变量来区分项目和运行环境，因此需要在`vue.config.js`配置  ``` js  module.exports = {    configureWebpack: {      plugins: [        new webpack.DefinePlugins({          \"process.env\": {            VUE_APP_PREFIX: JSON.stringify(process.env.VUE_APP_PREFIX)          }        })      ]    }  }  ```  ### 使用  ``` js  if (process.env.VUE_APP_PREFIX === 'stage') {    // 执行相应的操作  }  ```"},{title:"【学习笔记】之git",path:"/posts/git.html",strippedContent:'## Git介绍    - Git是分布式版本控制系统  - 集中式VS分布式：        1. 集中式版本控制系统，版本库集中存放在中央服务器，必须要联网才能工作,没有历史版本库。        2. 分布式版本控制系统，版本控制系统没有“中央服务器”，每个人电脑上都是一个完整的版本库。        3. 分布式系统优势：安全性更高，不需要联网，如果中央服务器故障，任何其他一个开发人员的本地都有最新的带有历史记录的版本库。  - 主要区别在于历史版本库的存放，集中式系统历史版本只存在于中央服务器，而分布式控制系统中每个本地库都有历史记录存放。    ## Git命令  ***    ### Git配置      $ git config --global user.name "Your Name"      $ git config --global user.email "email@example.com"    注意`git config`命令的`--global`参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。  ### 免密提交  在 git 文件夹的 config 配置文件修改 url    \turl = https://gitee.com/chen2114/studyNotes.git  \t改成:  \turl = https://账号:密码@gitee.com/chen2114/studyNotes.git      ### 创建版本库  #### 在当前目录创建git仓库      $ git init     #### 把文件添加到仓库      $ git add <file-name>      添加全部      $ git add .      $ git commit      添加描述      $ git commit -m \'描述\'      绕过了lint的检查      $ git commit -m 描述 --no-verify   `git add`可以反复多次使用，添加多个文件，`git commit`可以一次提交很多文件，在`git commit`命令后添加(-m \'····\')方便从历史记录里找到修改记录。    ### 查看工作区当前状态      $ git status     ### 查看文件修改内容      $ git diff    ### 版本回退      $ git reset -- hard HEAD^  HEAD指向的版本是当前版本，回到上一版本使用以上命令，如果回退上两个版本使用`HEAD^^`，如果回退版本数较大（如往上50个版本），使用`HEAD~50`。  ### 回退指定版本      $ git reset --hard commit_id  `commit_id`是指定版本号，是由SHA1计算出来的数字    ### 查看提交历史      $ git log       ### 查看命令历史      $ git reflog    ### 工作区、暂存区和版本库  > git与其他版本控制系统的不同之处就是有暂存区的概念，工作区就是电脑中能看到的目录，工作区有一个隐藏目录[.git]，这是git的版本库。版本库里有许多东西，最重要的是称为stage的暂存区。    将文件往版本库里添加时是分两步执行的:<br>  <ul>  <li>第一步是用`git add`把文件添加进去，实际上就是把文件修改添加到暂存区。</li>  <li>第二步是用`git commit`提交修改，实际上就是把暂存区的所有内容提交到当前分支。</li>  </ul>  Git是如何跟踪修改的，每次修改，如果不用git add到暂存区，那就不会加入到commit中。      ### 撤销修改  #### 丢弃工作区的修改      $ git checkout -- <file>  该命令是将文件在工作去的修改全部撤销，这里有两种情况：  <ol>  \t<li>一种是file自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li>  \t<li>一种是file已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li>  </ol>  总之，就是让这个文件回到最近一次git commit或git add时的状态。    #### 丢弃暂存区的修改  改乱了工作区某个文件的内容同时还添加到了暂存区，想丢弃修改时，先使用命令`git reset HEAD <file>`，之后按撤销工作区修改进行操作。  #### 进行了commit命令提交的修改  已经提交了不合适的修改到版本库时，想要撤销修改，使用版本回退命令，前提是没有推送到远程库.    ### 删除文件      $ git rm <file>  当你要删除文件`text.txt`的时候，可以采用命令：`rm test.txt`  这个时候有两种情况：<br>  第一种情况:的确要把`test.txt`删掉，那么可以执行      `$ git rm test.txt`      `$ git commit -m "remove test.txt"`  此时文件被删除，且删除记录上传本地库。<br>  第二种情况:误删文件，想恢复，这时候还没有`commit -m "remove test.txt"`，执行`git checkout test.txt`将文件恢复。<br>  如果执行完`git commit -m "remove test.txt"`后就不能用`checkout`恢复了，得用`git reset --hard HEAD^`，再从版本库写回到工作区。<br>  `git rm`用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。    ### 远程仓库  #### 创建SSH Key       $ ssh-keygen -t rsa -C "youremail@example.com"    #### 查看远程库信息      $ git remote -v    #### 关联远程仓库      $ git remote add origin https://github.com/username/repositoryname.git    #### 推送到远程仓库      $ git push -u origin master  -u 表示第一次推送master分支的所有内容，此后，每次本地提交后，只要有必要，就可以使用命令`$ git push origin master`推送最新修改。    #### 推送指定文件/文件夹到指定分支      git subtree push --prefix 文件或文件夹路径 origin 推送到的分支名    #### 从远程克隆      $ git clone https://github.com/usern/repositoryname.git      $ git clone -b 分支名 仓库地址  <strong>注意:</strong>当你不能使用`git@github.com`命令来进行推送和克隆，是因为没有安装密钥。添加私秘钥到`$ ssh-add ~/.ssh/id_rsa`<br>  如果添加失败可以先执行命令<code>$ eval \\`ssh-agent\\`</code> \\`是～键上的那个符号，然后再次添加私秘钥。<br>  用`$ ssh -T git@github.com`判断是否绑定成功。如果返回`successfully`表示成功。    #### 删除已经关联的远程库  \t& git remote rm remote-name  若远程库默认名字为origin，则    \t$ git remote rm origin    #### 本地库既关联GitHub，又关联码云  如原来已经关联了默认名origin的GitHub    1.先删除已关联的名为origin的远程库：  \t\t  \t$ git remote rm origin    2.然后，先关联GitHub的远程库：    \t$ git remote add github git@github.com:username/repositoryname.git    3.接着，再关联码云的远程库：    \t$ git remote add gitee git@gitee.com:username/repositoryname.git    同样注意，远程库的名称叫gitee，不叫origin了    **注意**多个关联后以上所以命令含的origin都换成相应的github或gitee    如果要推送到GitHub，使用命令：    \t$ git push github master    如果要推送到码云，使用命令：    \t$ git push gitee master    ### 分支管理  #### 查看分支      $ git branch    #### 创建分支      $ git branch <name>    #### 切换分支      $　git checkout <name>    #### 创建+切换分支      $ git checkout -b <name>    #### 创建+切换分支并从远处拉取该分支代码      $ git checkout -b <name> origin/<name>    #### 将指定分支的指定文件合并到当前所在分支      $ git checkout 指定分支名称 指定文件/文件夹路径    #### 给分支重命名      git branch -m oldName newName    #### 合并某分支到当前name分支      $ git merge <name>    ### 将某分支指定文件或文件夹替换当前分支的相应文件      $ git checkout <name> <filePath>    #### 删除分支      $ git branch -d <name>    #### 强行删除分支      $ git branch -D <name>  如果要丢弃一个没有被合并过的分支，可以通过以上命令来实现。    #### 查看分支合并图      $ git log --graph  当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。  用`git log --graph`命令可以看到分支合并图。    #### 普通模式合并分支      $ git merge --no-ff -m "description" <branchname>  通常进行分支合并时，git会使用Fast forward模式，删除分支后，分支信息会丢失，可以使用`--on-ff`参数，禁用Fast forward，需要时加上一个`-m`参数把commit描述写进去。这样进行合并后的历史有分支，能看出来曾经做过合并。    #### 保存工作现场      $ git stash    #### 查看工作现场      $ git stash list  #### 恢复工作现场       $ git stash pop  #### 在新建分支中修改bug时的推荐操作  转自[教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)讨论区“我有疫苗”用户的[评论](https://www.liaoxuefeng.com/discuss/001409195939432748a2c9fae3846bc98b3c2a547fa321b000/0015444271534391cee28ca27ed474d97b30b2b0ad6b534000)  <pre>  首先理清两个概念：      未被追踪的文件:指的是新建的文件或文件夹且还没加入到暂存区(新建的还没有被git add)      未加入到暂存区的文件:指的是已经被追踪过，但是没有加入到暂存区(已经执行过git add/commit的但是这次修改后还没有git add)      举例:          readme.md  已经被git add/git commit过，但是呢,我这次只是修改了,而且没有修改完,不能commit;          test    新建的文件夹,没有被git add/git commit;          有个bug需要处理,这时候我需要切换分支，去处理bug          正确的步骤:              git add test（让git去追踪这个新文件）              git stash保留现场     如果不执行这两个命令，那么在修改BUG完成之后git status，就会发现readme.md没有添加到暂存区，同时又多了个test文件,     但是自己的readme.md没有完成，万万不可以提交，这样导致bug的修改代码也提交不了。     所以需要git stash，这样在提交修改bug代码的时候 ，就不会看见readme.md 和 test。可以安心提交修改bug的代码。  </pre>    #### 从本地推送分支      $ git push origin branch-name  如果推送失败，先用git pull抓取远程的新提交；  #### 在本地创建和远程分支对应的分支      $ git checkout -b branch-name origin/branch-name  本地和远程分支的名称最好一致；  #### 建立本地分支和远程分支的关联      $ git branch --set-upstream branch-name origin/branch-name  #### 从远程抓取分支      $ git pull  如果有冲突，要先处理冲突。    ### 标签  git标签是版本库的快照，实际就是某个commit的指针，如果要找到某次版本的commit号，数字复杂不好找，使用tag取一个易于记住和理解的名字就方便许多，它跟某个commit绑在一起。（类似于域名和IP地址的关系？）  #### 新建标签       $ git tag <tagname>   默认为HEAD，也可以指定一个commit id。  #### 查看标签信息      $ git show <tagname>  #### 创建带有说明的标签      $ git tag -a <tagname> -m <description> <branchname> or commit_id  用-a指定标签名，-m指定说明文字  #### 查看所有标签      $ git tag  #### 推送某个标签到远程      $ git push origin <tagname>  #### 一次性推送全部尚未推送到远程的本地标签      $ git push origin --tags  #### 删除一个本地标签      $ git tag -d <tagname>  #### 删除一个远程标签      $ git push origin :refs/tags/<tagname>  '},{title:"【学习笔记】之less",path:"/posts/less.html",strippedContent:'### 变量  ``` less  @blue: #5B83AD;  .header {    color: @blue;  }    @side: left;  .rounded {  　border-@{side}-radius: 5px;  }  ```  ### 计算功能  ``` less  @base: 10%;  @filter: @base * 2;  @other: @base + @filter;    color: #888 / 4;  background-color: @base=color + #111;  height: 100% / 2 + filterl;    @var: 1px + 5; // 6px  width: (@var + 5 ) *2; // 被允许使用括号  border: (@width * 2) solid black; // 可以在符合属性中进行使用  ```  ### 嵌套  ``` less  #header {    color: black;    .navigation {      font-size: 12px;    }    .logo {      width: 300px;      &:hover { text-decoration: none }    }  }  ```  ### 继承  ``` less  .center{    display: flex;    justify-content: center;    align-items: center;  }    .div:extend(.center) {    width: 400px;  }  ```  ### 颜色函数  ``` less  lighten(@color, 10%);     // 返回一个比@color低10％更轻的颜色  darken(@color, 10%);      // 返回一个比@color高10％较暗的颜色  saturate(@color, 10%);    // 返回比@color多饱和度10％的颜色  desaturate(@color, 10%);  // 返回一个比@color少饱和度10％的颜色  fadein(@color, 10%);      // 返回一个比@color少10％透明度的颜色  fadeout(@color, 10%);     // 返回一个比@color多10％透明度的颜色  fade(@color, 50%);        // 返回一个颜色透明度为50％的颜色  spin(@color, 10);         // 返回色调比@color大10度的颜色  spin(@color, -10);        // 返回一个比@color小10度色调的颜色  mix(@color1, @color2);    // 返回一个混合@ color1和@ color2的颜色  ```  ### Math函数  ``` less  round(1.67); // returns `2`  ceil(2.4);   // returns `3`  floor(2.6);  // returns `2`  percentage(0.5); // returns `50%`  ```  ### Mixin  ``` less  // 带参数的混合  .border-radius (@radius: 5px) {          border-radius: @radius;     -moz-border-radius: @radius;  -webkit-border-radius: @radius;  }  #header {    .border-radius(4px);  }    .box-shadow (@x: 0, @y: 0, @blur: 1px, @color: #000) {    box-shadow: @arguments;    -moz-box-shadow: @arguments;    -webkit-box-shadow: @arguments;  }  .box-shadow(2px, 5px);    // 匹配模式  .mixin (dark, @color) {    color: darken(@color, 10%);  }  .mixin (light, @color) {    color: lighten(@color, 10%);  }  .mixin (@_, @color) {// @_ 接受任意值    display: block;  }    .class {    .mixin(light, #888);  }  ```  ### 插入文件  ``` less  @import "lib.less";  @import "lib";  @import "lib.css";  ```  ### 导引表达式  ``` less  .generate-font(@n, @i: 12) when (@i <= @n) {    .fs@{i} {      font-size: @i * 1px;    }    .generate-font(@n, (@i + 1));  }    .generate-font(40);  // 运行结果  // .fs12 { font-size: 12px } .fs13 { font-size: 13px }......fs40 { font-size: 40px }  ```  ### 避免编译  有时候我们需要输出一些不正确的CSS语法或者使用一些 less不认识的专有语法。要输出这样的值我们可以在字符串前加上一个 ~，并将要避免编译的值用 “”包含起来。  ``` less  .class {    filter: ~"ms:alwaysHasItsOwnSyntax.For.Stuff()";  }  ```  ### JavaScript表达式  ``` less  @var: `"hello".toUpperCase() + \'!\'`; // @var :"HELLO!"    @str: "hello";  @var: ~`"@{str}".toUpperCase() + \'!\'`; //@var: HELLO!;    @height: `document.body.clientHeight`;    @color: color(`window.colors.baseColor`);  ```'},{title:"【学习笔记】之markdown",path:"/posts/markdown.html",strippedContent:'# 一级标题    ## 二级标题    这是一级标题  ==========     这是二级标题  ----------    # 一级标题 #  ## 二级标题 ##    ### 无序列表    * 1    * 2    * 3    + 1    + 2    + 3    - 1    - 2    - 3    ### 有序列表    1. 列表1    2. 列表2    3. 列表3    * 前方高能    > 注意事项：请佩戴好耳机    ### 分割线    ***    ---    ___    ### 行内式    * [百度](https://www.baidu.com/)查找    ### 参数式    [name]: https://www.baidu.com/ "名称"    [百度]: https://www.baidu.com/ "百度"    * 这是[name]，这边是[百度]    ### 图片    ![图片](https://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dbb44aed2e738bd4576dad43a28b87d6277ff970.jpg)    ------    [动图]: https://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dbb44aed2e738bd4576dad43a28b87d6277ff970.jpg    参数式图片：![动图]    ### 代码框    `<p>单行代码用``</p>`    ``` 多行用      <p>多行代码用```</p>      <p>多行代码用```</p>      <p>多行代码用```</p>    ```    ### 表格    \x3c!-- 冒号表示对齐方式 --\x3e    | name | age | sex |    |:-----|:---:|----:|    | marray | 15 | 男 |    | lily | 15 | 男 |      表头1   | 表头2    ------  | ------    content | cell    content | cell      学号 | 姓名 | 分数    - | - | -    12 | 小米 | 12    5  | 小红 | 60    ### 字体样式    *字体倾斜*     _字体倾斜_    **字体加粗**    __字体加粗__    ### 转义    * \\\\    * \\~    * \\+    * \\!    ### 删除线    ~~请把我删除~~    ### 页面内跳转    * html跳转      * [1.1点击跳转](#jump)  ### <a href="#jump">点击跳转</a>    <br>    <br>    <br>    <br>    <br>    <br>    <br>    <br>    <br>    <br>    <br>    <br>    <br>    <br>    <br>    <br>    <br>    <br>    <br>    <br>    <h3 id="jump">跳转到的地方</h3>'},{title:"【学习笔记】之scss/sass",path:"/posts/scss.html",strippedContent:'### 编译风格  * nested：嵌套缩进的css代码，它是默认值。  * expanded：没有缩进的、扩展的css代码。  * compact：简洁格式的css代码。  * compressed：压缩后的css代码。    生产环境当中，一般使用最后一个选项  ```  sass --style compressed test.sass test.css  ```  ### 变量  ``` scss  $blue: #1875e7;  div {    color: $blue;  }    $side: left;  .rounded {  　border-#{$side}-radius: 5px;  }  ```  ### 计算功能  ``` scss  body {  　margin: (14px/2);  　top: 50px + 100px;  　right: $var * 10%;  }  ```  ### 嵌套  ``` scss  div {    h1 {      color: red;      border: {        color: red;        width: 1px;      }      &:hover {        color: #ffb3ff;      }    }  }  ```  ### 注释  ASS共有两种注释风格。  标准的CSS注释 /* comment */ ，会保留到编译后的文件。    单行注释 // comment，只保留在SASS源文件中，编译后被省略。    在/*后面加一个感叹号，表示这是"重要注释"。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。  ### 继承  ``` scss  .class1 {    border: 1px solid #ddd;  }  .class2 {  　@extend .class1;  　font-size:120%;  }  ```  ### Mixin  ``` scss  @mixin left($value: 10px) {  　float: left;  　margin-left: $value;  }  div {  　@include left(20px);  }  ```  ### 颜色函数  ``` scss  lighten(#cc3, 10%) // #d6d65c  darken(#cc3, 10%) // #a3a329  grayscale(#cc3) // #808080  complement(#cc3) // #33c  ```  ### 插入文件  ``` scss  @import "path/filename.scss";  @import "foo.css";  ```  ### 条件语句  ``` scss  p {  　@if 1 + 1 == 2 { border: 1px solid; }  　@if 5 < 3 { border: 2px dotted; }  }  @if lightness($color) > 30% {  　background-color: #000;  } @else {  　background-color: #fff;  }  ```  ### 循环语句  ``` scss  @for $i from 1 to 10 {  　.border-#{$i} {  　　border: #{$i}px solid blue;  　}  }    $i: 6;  @while $i > 0 {  　.item-#{$i} { width: 2em * $i; }  　$i: $i - 2;  }    @each $member in a, b, c, d {  　.#{$member} {  　　background-image: url("/image/#{$member}.jpg");  　}  }  ```  ### 自定义函数  ``` scss  @function double($n) {  　@return $n * 2;  }  #sidebar {  　width: double(5px);  }  ```'},{title:"【学习笔记】之es6",path:"/posts/es6.html",strippedContent:"### let和const    > let和const为块级作用域，var为全局变量，const声明一个只读的常量。一旦声明，常量的值就不能改变。  ### Arrow Function 箭头函数    ``` js    const number = [5, 16, 80, 4]    number.map(function(num, index){      console.log(num, index)    })    number.map((num,index) => {      console.log(num)    })    ```  ### 模板字符    ``` js      let template = `User ${user.name} is not authorized to do ${user.age}.`      let template = `      <ul>        <% for(let i=0; i < data.supplies.length; i++) { %>          <li><%= data.supplies[i] %></li>        <% } %>      </ul>      `    ```  ### 字符串的新增方法    * includes()：返回布尔值，表示是否找到了参数字符串    * startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部    * endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部    ``` js    let s = 'Hello world!'    s.startsWith('world', 6) // true    s.endsWith('!') // true    s.endsWith('Hello', 5) // true    s.includes('Hello', 6) // false    ```    * repeat(): 返回一个新字符串，表示将原字符串重复n次    ``` js    'x'.repeat(3) // \"xxx\"    ```    * padStart(): 用于头部补全    * padEnd(): 用于尾部补全    ``` js    'x'.padStart(4) // '   x'    '1'.padStart(10, '0') // \"0000000001\"    09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\"    ```    * trim(): 去除空格    * trimStart()    * trimStart()    ``` js    const s = '  abc  ';    s.trim() // \"abc\"    s.trimStart() // \"abc  \"    s.trimEnd() // \"  abc\"    ```  ### 正则的扩展    * match()    * replace()    * search()    * split()    ``` js    let str=\"1 plus 2 equal 3\"    str.match(/\\d+/g) // 1,2,3    str.replace(/\\d+/g, \"@\") // @ plus @ equal @    str.search(\"plus\") // 2    str.split(\" \") // [\"1\", \"plus\", \"2\", \"equal\", \"3\"]    ```  ### 数值的扩展    ``` js    Number.parseInt('12.34') // 12    Number.parseFloat('123.45#') // 123.45    ```  ### 函数的扩展    ``` js    function foo(x = 5, y = 6) {      console.log(x, y);    }    foo(undefined, null) // 5 null    // 上面代码中，x参数对应undefined，结果触发了默认值，y参数等于null，就没有触发默认值。    function foo(...values) {      console.log(values);    }    foo(1, 2, 5, 6) // [1, 2, 5, 6]    // 上面代码中，利用 rest 参数，可以向该函数传入任意数目的参数。    ```  ### 数组的扩展    * 扩展运算符 '...'    ``` js    function push(array, ...items) {      array.push(...items);    }    function add(x, y) {      return x + y;    }    const numbers = [4, 38];    add(...numbers) // 42    ```    * Array.from(): 将两类对象转为真正的数组    ``` js    let arrayLike = {      '0': 'a',      '1': 'b',      '2': 'c',      length: 3    }    let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']    ```    * Array.of(): 方法用于将一组值，转换为数组    ``` js    Array.of(3, 11, 8) // [3,11,8]    ```    * find(): 用于找出第一个符合条件的数组成员    * findIndex(): 返回第一个符合条件的数组成员的位置    ``` js    let arr = [1, 2, 3, 4, 5, 6]    arr.find((value, index, arr) => value > 5) // 6    arr.findIndex((value, index, arr) => value > 2) // 2    ```    * fill(): fill方法使用给定值，填充一个数组    ``` js    new Array(3).fill(7) // [7, 7, 7]    let arr = ['a', 'b', 'r']    arr.fill(5) // [5, 5, 5]    ```    * entries(): 对键值对的遍历    * keys(): 对键名的遍历    * values(): 对键值的遍历    ``` js    let arr = ['a', 'b', 'r']    for (let index of arr.keys()) {      console.log(index);    }    // 0    // 1    // 2    for (let item of arr.values()) {      console.log(item);    }    // 'a'    // 'b'    // 'r'    for (let [index, item] of arr.entries()) {      console.log(index, item);    }    // 0 'a'    // 1 'b'    // 2 'r'    ```    * includes(): 返回一个布尔值，表示某个数组是否包含给定的值    ``` js    [1, 2, 3].includes(2)     // true    [1, 2, 3].includes(4)     // false    [1, 2, NaN].includes(NaN) // true    ```    >indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。    * sort(): 排序    ``` js    let arr = [1, 50, 8, 19]    arr.sort((a, b) => a - b) // [1, 8, 19, 50]    arr.sort((a, b) => b - a) // [50, 19, 8, 1]    ```  ### 对象的扩展    * Object.assign(): 用于对象的合并    ``` js    const target = { a: 1, b: 1 };    const source1 = { b: 2, c: 2 };    const source2 = { c: 3 };    Object.assign(target, source1, source2);    target // {a:1, b:2, c:3}    ```    * Object.keys()    * Object.values()    * Object.entries()    ``` js    let {keys, values, entries} = Object    let obj = { a: 1, b: 2, c: 3 }    for (let key of Object.keys(obj)) {      console.log(key); // 'a', 'b', 'c'    }    for (let value of Object.values(obj)) {      console.log(value); // 1, 2, 3    }    for (let [key, value] of Object.entries(obj)) {      console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]    }    ```  ### 遍历方法    * for...in          根据key遍历，遍历对象时会从原型上继承属性，可以用hasOwnProperty（）识别出继承属性。    * for...of          根据值遍历，for...of用来遍历数据，例如数组中的值，但是也可以遍历字符串，支持Map和Set对象的遍历，避免了所有for...in的弊端，与forEach相比可以正确响应break，continue，return语句    * forEach          根据index遍历，forEach一般只能适用于数组,功能是从头到尾把数组遍历一遍，可以有三个参数，后两个可以不写，效率和for循环相近    * map          根据index遍历，和forEach相比，使用方法一样有三个参数，map只能对元素进行加工处理，产生一个新的数组对象    * filter          对原数组进行过滤筛选，生成新的数组,使用和map样有三个参数。如果对空数组进行筛选，会返回undefined。filter不会改变原数组。    * for          常规语句遍历，可循环数字,字符串，数组  ### Symbol    > 凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突    ``` js    let s1 = Symbol('foo')    let s2 = Symbol('bar')    s1 // Symbol(foo)    s2 // Symbol(bar)    s1 === s2 // false    ```  ### Set 和 Map 数据结构    * Set    ``` js    let set = new Set([1, 2, 3, 4, 4])      [...set] // [1, 2, 3, 4]    Array.from(set) // [1, 2, 3, 4]    set.add(5) // {1, 2, 3, 4, 5}    set.size // 5    set.has(1) // true    set.delete(3) // 返回一个布尔值，表示删除是否成功    set.clear() // 清除所有成员，没有返回值      let set = new Set(['red', 'green', 'blue']);      for (let item of set) {      console.log(item)    }    // red    // green    // blue    ```    * Map    ``` js    let obj = {'name': '张三', 'title': 'Author'}    // 对象 转 Map    const map = new Map(Object.entries(obj))      [...map.keys()] // ['name', 'title']    [...map.values()] // ['张三', 'Author']    [...map] // [['name', '张三'], ['title', 'Author']]    Array.from(map) // ['name', '张三', 'title', 'Author']      map.set(1, '男') // {'name'=>'张三', 'title'=>'Author', 1=>'男'}    map.get(1) // '男'    map.has('name') // true    map.size() // 3    map.delete('title') // 返回一个布尔值，表示删除是否成功。    map.clear() // 清除所有成员，没有返回值      // 注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。    map.set(['a'], 555)    map.get(['a']) // undefined      const k1 = ['a']    const k2 = ['a']    map.set(k1, 111).set(k2, 222)    map.get(k1) // 111    map.get(k2) // 222      const map = new Map([      ['F', 'no'],      ['T',  'yes'],    ])      for (let key of map.keys()) {      console.log(key)    }    // \"F\"    // \"T\"      for (let value of map.values()) {      console.log(value)    }    // \"no\"    // \"yes\"      for (let [key, value] of map) {      console.log(key, value)    }    // \"F\" \"no\"    // \"T\" \"yes\"    ```  ### Proxy 和 Reflect    > Proxy： 可以对外界的访问进行过滤和改写， Reflect： 可以拿到语言内部的方法    ``` js    var obj = new Proxy({}, {      get: function (target, key, receiver) {        console.log(`getting ${key}!`);        return Reflect.get(target, key, receiver);      },      set: function (target, key, value, receiver) {        console.log(`setting ${key}!`);        return Reflect.set(target, key, value, receiver);      }    });    obj.count = 1    //  setting count!    ++obj.count    //  getting count!    //  setting count!    //  2    ```  ### Promise    > Promise 是异步编程的一种解决方案    ``` js    function fetchPost(url, params) {      return new Promise((resolve, reject) => { // 成功调用resolve，失败调用reject        axios.post(url, params)          .then(response => {            resolve(response.data)          }, err => {            reject(err)          })          .catch((error) => {            reject(error)          })      })    }    // 执行方法    fetchPost(url, params).then(val => {      console.log(val)    }).catch(err => {      console.log(err)    })    ```  ### Generator    > 函数会返回一个遍历器对象,可以依次遍历 Generator 函数内部的每一个状态    ``` js    function* helloWorldGenerator() {      yield 'hello';      yield 'world';      return 'ending';    }    var hw = helloWorldGenerator();    hw.next()    // { value: 'hello', done: false }    hw.next()    // { value: 'world', done: false }    hw.next()    // { value: 'ending', done: true }    hw.next()    // { value: undefined, done: true }    ```    > 异步任务的封装    ``` js    const fetch = require('node-fetch')    function* gen() { // 该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息      const url = 'https://api.github.com/users/github'      yield fetch(url)    }    // 执行方法    gen().next().value.then(data => {      return data.json()    }).then(data => {      gen().next(data)    })    ```    > Generator和Promise配合使用    ``` js    function readFile(fileName) {      return new Promise((resolve, reject) => {        require('fs').readFile(fileName, (error, data) => {          if (error) return reject(error)          resolve(data)        })      })    }    function* gen() {      const f1 = yield readFile('/etc/fstab')      const f2 = yield readFile('/etc/shells')      console.log(f1.toStaing())      console.log(f2.toStaing())    }    // 执行方法    gen().next().value.then(data => { // next(data)中的data===f1      return gen().next(data).value    }).then(data => {        gen().next(data)      })    ```  ### async    > Generator 函数的语法糖    ``` js    async function gen() {      const f1 = await readFile('/etc/fstab')      const f2 = await readFile('/etc/shells')      console.log(f1.toStaing())      console.log(f2.toStaing())    }    // 任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。    // 解决办法:    async function f() {      try {        await readFile('/etc/fstab')      } catch(err) {        console.log(err)      }    }    // 执行方法    f().then(v => console.log(v))    ```  ### Class    ``` js    class Point {      constructor(x, y) {        this.x = x;        this.y = y;      }        toString() {        return '(' + this.x + ', ' + this.y + ')';      }    }    // 类的继承    class ColorPoint extends Point {      constructor(x, y, color) {        super(x, y); // 调用父类的constructor(x, y)        this.color = color;      }        toString() {        return this.color + ' ' + super.toString(); // 调用父类的toString()      }    }    ```  ### static关键字    > 被static修饰的变量属于类变量，可以通过类名.变量名直接引用，而不需要new出一个类来，    类似 Array.from()中 from()为static， [1, 2, 3, 4, 5, 6].find()不是static，    ``` js    class Point {      constructor(x, y) {        this.x = x;        this.y = y;      }      toString() {        return '(' + this.x + ', ' + this.y + ')';      }      static toPoint() {        return '(' + this.x + ', ' + this.y + ')';      }    }    // 执行方法    const p = new Point()    p.toString()    Point.toPoint()    ```"},{title:"vue-cli3项目常用项配置",path:"/posts/configuration.html",strippedContent:"[一份完整的vue-cli3项目基础配置项](https://github.com/hangjob/vue-admin) ### vue.config.js  完整的架构配置  ``` js  const path = require('path');  const UglifyJsPlugin = require('uglifyjs-webpack-plugin') // 去掉注释  const CompressionWebpackPlugin = require('compression-webpack-plugin'); // 开启压缩  const { HashedModuleIdsPlugin } = require('webpack');    function resolve(dir) {    return path.join(__dirname, dir)  }    const isProduction = process.env.NODE_ENV === 'production';    // cdn预加载使用  const externals = {    'vue': 'Vue',    'vue-router': 'VueRouter',    'vuex': 'Vuex',    'axios': 'axios',    \"element-ui\": \"ELEMENT\"  }    const cdn = {    // 开发环境    dev: {      css: [        'https://unpkg.com/element-ui/lib/theme-chalk/index.css'      ],      js: []    },    // 生产环境    build: {      css: [        'https://unpkg.com/element-ui/lib/theme-chalk/index.css'      ],      js: [        'https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js',        'https://cdn.jsdelivr.net/npm/vue-router@3.0.1/dist/vue-router.min.js',        'https://cdn.jsdelivr.net/npm/vuex@3.0.1/dist/vuex.min.js',        'https://cdn.jsdelivr.net/npm/axios@0.18.0/dist/axios.min.js',        'https://unpkg.com/element-ui/lib/index.js'      ]    }  }    module.exports = {    lintOnSave: false, // 关闭eslint    productionSourceMap: false,    publicPath: './',     outputDir: 'dist', // 生成文件的目录名称    chainWebpack: config => {        config.resolve.alias        .set('@', resolve('src'))        // 压缩图片      config.module        .rule('images')        .test(/\\.(png|jpe?g|gif|svg)(\\?.*)?$/)        .use('image-webpack-loader')        .loader('image-webpack-loader')        .options({ bypassOnDebug: true })            // svg rule loader      // 安装npm i svg-sprite-loader      const svgRule = config.module.rule('svg') // 找到 svg-loader      svgRule.uses.clear() // 清除已有 loader      svgRule // 添加新的 svg loader        .test(/\\.svg$/)        .exclude.add(/node_modules/).end()        .include.add(resolve('src/svg')).end() // 处理svg目录        .use('svg-sprite-loader')        .loader('svg-sprite-loader')        .options({          symbolId: 'icon-[name]'        })        // webpack 会默认给commonChunk打进chunk-vendors，所以需要对webpack的配置进行delete      config.optimization.delete('splitChunks')        config.plugin('html').tap(args => {        if (process.env.NODE_ENV === 'production') {          args[0].cdn = cdn.build        }        if (process.env.NODE_ENV === 'development') {          args[0].cdn = cdn.dev        }        return args      })        // 开启分析打包日志      // 安装npm i webpack-bundle-analyzer -D      config        .plugin('webpack-bundle-analyzer')        .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin)    },      configureWebpack: config => {      // 去掉注释、去掉console.log      // 安装npm i uglifyjs-webpack-plugin -D      const plugins = [];        if (isProduction) {        plugins.push(          new UglifyJsPlugin({            uglifyOptions: {              output: {                comments: false, // 去掉注释              },              warnings: false,              compress: {                drop_console: true,                drop_debugger: false,                pure_funcs: ['console.log'] // 移除console              }            }          })        )        // 服务器也要相应开启gzip        plugins.push(          new CompressionWebpackPlugin({            algorithm: 'gzip',            test: /\\.(js|css)$/,// 匹配文件名            threshold: 10000, // 对超过10k的数据压缩            deleteOriginalAssets: false, // 不删除源文件            minRatio: 0.8 // 压缩比          })        )          // 用于根据模块的相对路径生成 hash 作为模块 id, 一般用于生产环境        // 只打包改变的文件        // 安装npm i webpack -D        plugins.push(          new HashedModuleIdsPlugin()        )          // 开启分离js        config.optimization = {          runtimeChunk: 'single',          splitChunks: {            chunks: 'all',            maxInitialRequests: Infinity,            minSize: 1000 * 60,            cacheGroups: {              vendor: {                test: /[\\\\/]node_modules[\\\\/]/,                name(module) {                  // 排除node_modules 然后吧 @ 替换为空 ,考虑到服务器的兼容                  const packageName = module.context.match(/[\\\\/]node_modules[\\\\/](.*?)([\\\\/]|$)/)[1]                  return `npm.${packageName.replace('@', '')}`                }              }            }          }        };          // 取消webpack警告的性能提示        config.performance = {          hints: 'warning',          //入口起点的最大体积          maxEntrypointSize: 1000 * 500,          //生成文件的最大体积          maxAssetSize: 1000 * 1000,          //只给出 js 文件的性能提示          assetFilter: function (assetFilename) {            return assetFilename.endsWith('.js');          }        }          // 打包时npm包转CDN        config.externals = externals;      }        return { plugins }    },      pluginOptions: {      // 配置全局less      // 安装npm i style-resources-loader      // 安装npm i vue-cli-plugin-style-resources-loader      'style-resources-loader': {        preProcessor: 'less',        patterns: [resolve('./src/style/theme.less')]      }    },    devServer: {      open: false, // 自动启动浏览器      host: '0.0.0.0', // localhost      port: 6060, // 端口号      https: false,      hotOnly: false, // 热更新      proxy: {        '^/sso': {          target: process.env.VUE_APP_SSO, // 重写路径          ws: true,   //开启WebSocket          secure: false,      // 如果是https接口，需要配置这个参数          changeOrigin: true        }      }    }  }  ```    ### html模板配置cdn  ``` html  <!DOCTYPE html>  <html lang=\"en\">    <head>    <meta charset=\"utf-8\">    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">    <link rel=\"icon\" href=\"<%= BASE_URL %>favicon.ico\">    <title><%= htmlWebpackPlugin.options.title %></title>    <% for (var i in        htmlWebpackPlugin.options.cdn && htmlWebpackPlugin.options.cdn.css) { %>    <link href=\"<%= htmlWebpackPlugin.options.cdn.css[i] %>\" rel=\"preload\" as=\"style\" />    <link href=\"<%= htmlWebpackPlugin.options.cdn.css[i] %>\" rel=\"stylesheet\" />    <% } %>  </head>    <body>    <noscript>        <strong>We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled.            Please enable it to continue.</strong>    </noscript>    <div id=\"app\"></div>    \x3c!-- built files will be auto injected --\x3e    <% for (var i in        htmlWebpackPlugin.options.cdn && htmlWebpackPlugin.options.cdn.js) { %>    <script src=\"<%= htmlWebpackPlugin.options.cdn.js[i] %>\"><\/script>    <% } %>  </body>  </html>  ```    ### 查看打包分析报告  生成分析报告  ```  $ npm run build --report  ```    ### 设置 vscode 识别别名  在vscode中插件安装栏搜索 Path Intellisense 插件，打开settings.json文件添加 以下代码 \"@\": \"${workspaceRoot}/src\"，安以下添加  ``` js  {    \"workbench.iconTheme\": \"material-icon-theme\",    \"editor.fontSize\": 16,    \"editor.detectIndentation\": false,    \"guides.enabled\": false,    \"workbench.colorTheme\": \"Monokai\",    \"path-intellisense.mappings\": {        \"@\": \"${workspaceRoot}/src\"    }  }  ```  在项目package.json所在同级目录下创建文件jsconfig.json  ``` js  {    \"compilerOptions\": {      \"target\": \"ES6\",      \"module\": \"commonjs\",      \"allowSyntheticDefaultImports\": true,      \"baseUrl\": \"./\",      \"paths\": {        \"@/*\": [\"src/*\"]      }    },    \"exclude\": [      \"node_modules\"    ]  }  ```    ### 配置环境变量开发模式、测试模式、生产模式  在根目录新建    #### .env.development  ```  # 开发环境  NODE_ENV='development'    # 设置基础api  VUE_APP_BASE_API = '/dev-api'  ```    #### .env.test  ```  # 如果我们在.env.test文件中把NODE_ENV设置为test的话，那么打包出来的目录结构是有差异的  NODE_ENV = 'production'    VUE_APP_MODE = 'test'    # 设置基础api  VUE_APP_BASE_API='/test-api'    outputDir = test  ```    #### .env.production  ```  NODE_ENV = 'production'    VUE_APP_SSO='http://http://localhost:9080'  ```    #### package.json  ``` json  \"scripts\": {    \"build\": \"vue-cli-service build\", //生产打包    \"lint\": \"vue-cli-service lint\",    \"dev\": \"vue-cli-service serve\", // 开发模式    \"test\": \"vue-cli-service build --mode test\", // 测试打包    \"publish\": \"vue-cli-service build && vue-cli-service build --mode test\" // 测试和生产一起打包   }  ```"},{title:"资源汇总",path:"/posts/assets.html",strippedContent:"## 插件  ### [element-ui](https://element.eleme.cn/#/zh-CN)    > 基于 Vue 2.0 的桌面端组件库    ### [vant](https://youzan.github.io/vant/#/zh-CN/intro)    > 轻量、可靠的移动端 Vue 组件库    ### [echarts](https://www.echartsjs.com/zh/index.html)    > 可高度个性化定制的数据可视化图表    ### [echarts gallery](https://gallery.echartsjs.com/explore.html#sort=rank~timeframe=all~author=all)    > echarts示例    ### [swiper](https://www.swiper.com.cn/)    > Swiper是滑动特效插件，能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果    ### [vue-seamless-scroll](https://chenxuan1993.gitee.io/component-document/index_prod#/component/seamless-default)    > vue组件，图片滚动、无缝滚动    ### [SuperSlide](http://www.superslide2.com/)    > 基于jQuery的ui插件，常用特效：焦点图/幻灯片、Tab标签切换、图片滚动、无缝滚动等    ### [TweenMax](https://www.tweenmax.com.cn/)    > 适用于移动端和现代互联网的超高性能专业级动画插件    ### [Bootstrap](https://v3.bootcss.com/)    >  HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目    --------------------------------------------------------------------    ### [Lodash](https://www.lodashjs.com/)    > 一致性、模块化、高性能的 JavaScript 实用工具库    ### [mock](http://mockjs.com/)    > 生成随机数据，拦截 Ajax 请求    ### [axios](http://www.axios-js.com/zh-cn/docs/)    > Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。    ### [vue Router](https://router.vuejs.org/zh/guide/#javascript)    > 是Vue.js 官方的路由管理器    ### [vuex](https://vuex.vuejs.org/zh/)    > Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。    ### [webpack](https://www.webpackjs.com/)    > webpack 是一个现代 JavaScript 应用程序的静态模块打包器    ### [QRCode](https://www.jianshu.com/p/d3883e020d99)    > 用于制作二维码    ### [Moment](http://momentjs.cn/)    > JavaScript 日期处理类库    ### [VuePress](https://vuepress.vuejs.org/zh/)    > Vue 驱动的静态网站生成器    ----------------------------------------------------------------------    ## 其它  ### [iconfont](https://www.iconfont.cn/)    > 图标库    ### [vue-element-admin](https://panjiachen.github.io/vue-element-admin)    > vue后台项目教程"},{title:"【学习笔记】之css",path:"/posts/css.html",strippedContent:'### 初始化    ``` css    @charset "utf-8";    /* CSS Document */    html,body{height: 100%;}    html,body,div,form,img,ul,ol,li,dl,dt,dd{margin:0px; padding:0px;}    body{margin:0 auto;padding:0;border:0; font-family:"微软雅黑"; font-size: 14px;}    select,input,textarea{vertical-align:middle; padding:0; margin:0;}    textarea{resize:none;}    img{border:0;}    ol,ul,li{list-style:none;}    a{text-decoration:none; transition: ease-in-out .3s;}    a,img,input,textarea,select,button,area{outline:none;}    *{-webkit-box-sizing: border-box;        -moz-box-sizing: border-box;              box-sizing: border-box;}    /*清除浮动*/    .clearfix:after{content:\'\';display:block;height:0;clear:both;visibility:hidden;}    .clearfix{*zoom:1; _zoom:1;}    .lfloat{float:left;}    .rfloat{float:right;}    table{border-collapse:collapse;border-spacing:0;}    td,th{padding:0;}      body{position: relative; width: 100%; height: 100%;}      /*修改IE下  select*/    select::-ms-expand{display: none; appearance:none; -moz-appearance:none; -webkit-appearance:none; -ms-appearance:none;}    ```  ### 鼠标悬停翻转X 翻转Y 旋转翻转X    ``` css    .flip-x {transition: .6s ease-in-out;}    .flip-x:hover {transform: rotateX(360deg);}    ```  ### 翻转Y    ``` css    .flip-y {transition: .6s ease-in-out;}    .flip-y:hover {transform: rotateY(360deg);}    ```  ### 旋转360°    ``` css    .rotate360 {transition: .6s ease-in-out;}    .rotate360:hover {transform: rotate(360deg) scale(1.25);}    ```  ### 文字单行超出…    ``` css    {white-space:nowrap; overflow: hidden; text-overflow: ellipsis;}    ```  ### 文字多行超出…    ``` css    {display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2; overflow: hidden;}    ```  ### Flex布局【IE11+】    >注意：设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效  #### 设置在容器上的属性    * flex-direction: row | row-reverse | column | column-reverse; item的排列方向    * flex-wrap: nowrap | wrap | wrap-reverse; 换行方式    * flex-flow: row nowrap; flex-direction和flex-wrap的简写    * justify-content: flex-start | flex-end | center | space-between | space-around; item在主轴上的对齐方式    * align-items: flex-start | flex-end | center | baseline | stretch; item在交叉轴上如何对齐    * align-content: flex-start | flex-end | center | space-between | space-around | stretch; 多根轴线的对齐方式,如果项目只有一根轴线，该属性不起作用  #### item的属性    * order: 0; 定义item的排列顺序    * flex-grow: 0; 定义item的放大比例    * flex-shrink: 1; 定义item的缩小比例    * flex-basis: auto; 定义了在分配多余空间之前，item占据的主轴空间    * flex: 0 1 auto; flex-grow, flex-shrink 和 flex-basis的简写    * align-self: auto | flex-start | flex-end | center | baseline | stretch; 允许单个iem有与其他项目不一样的对齐方式，可覆盖align-items属性  ### div模拟table    ``` css    .eui-display-table {display: table; width:100%;}    .eui-display-table .thead {display: table-header-group;}    .eui-display-table .tbody {display: table-column-group;}    .eui-display-table .tfoot {display: table-footer-group;}    .eui-display-table .tr {display: table-row;}    .eui-display-table .th {display: table-cell; vertical-align: middle;}    .eui-display-table .td {display: table-cell; vertical-align: middle;}    ```  ### 文字单行时居中，超过单行时居左    ``` html    <div class="eui-text-align-center">      <div class="con">              </div>    </div>    ```    ``` css    .eui-text-align-center {text-align: center;}    .eui-text-align .con {display:inline-block; text-align: left;}    ```      ### 图片或背景变灰色    ``` css    img {-webkit-filter: grayscale(1);}    a {-webkit-filter: grayscale(1); cursor: no-drop;}    ```  ### 输入框placeholder样式    ``` css    input::-webkit-input-placeholder {color: #4d8fd9;}    ```  ### 插入图片实现cover    ``` css    {display: block; width: 100%; height: 100%;object-fit: cover;}    ```  ### content获取属性值    ``` html    <a href="#" data-label="Country scenery"></a>    ```    ``` css    a:before {content: attr(data-label);}    ```  ### 底部自适应    内容不超过一屏时，底部固定在浏览器底部，内容超过一屏时，底部跟随在页面之后，将所有页面内容放在写了padding-bottom的`<div class="eui-con">`中，padding-bottom的值与底部的高度相同    ``` html    <body>      <div class="eui-con">        ……        <div class="eui-footer">          </div>      </div>    </body>    ```    ``` css    html, body {height: 100%;}    body {position: relative; min-height: 100%; height: auto !important; height: 100%}    .eui-con {padding-bottom: 50px;}    .eui-footer {position: absolute; bottom: 0; width: 100%; height: 50px; overflow: hidden;}    ```  ### 鼠标悬停图片放大    ``` css      a img {display: block;-webkit-transition: 0.5s,-webkit-transform 0.5s; transition: 0.5s, transform 0.5s;}      a:hoverimg {-webkit-transform: scale3d(1.1,1.1,1); transform: scale3d(1.1,1.1,1);}    ```  ### 滚动条样式修改    ``` css    ::-webkit-scrollbar {width: 8px; height: 8px;} /* 定义滚动条高宽及背景高宽分别对应横竖滚动条的尺寸 */    ::-webkit-scrollbar-track {background: none;} /* 定义滚动条轨道内阴影+圆角 */    ::-webkit-scrollbar-thumb {border-radius: 10px; background-color: rgba(0,0,0,.15);} /* 定义滑块内阴影+圆角 */    ```  ### 鼠标经过半透明    ``` css    .hover-opacity a:hover {filter: alpha(opacity=75); opacity: 0.75;}    ```  ### 鼠标经过图片半透明    ``` css    .hover-opacity a img {transition: 0.2s;}    .hover-opacity a:hover img {filter: alpha(opacity=75); opacity: 0.75;}    ```  ### CSS三角形    ``` css    {border-width: 6px;border-style: solid; border-color: transparent transparent #fff transparent;}    ```  ### pie.htc    ``` css    {behavior:url(css/pie.htc);}    ```  ### IE8背景图全屏拉伸    ``` css    {background: url(../images/bg.jpg) no-repeat top center fixed; background-size: cover; filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\'images/bg.jpg\',sizingMethod=\'scale\');}    ```  ### 媒介    ``` css    @media screen and(min-width: 300px) {      }    @media screen and(max-width: 480px) {      }    ```  ### 表格单元格防止撑开    ``` css    table {table-layout: fixed;word-wrap: break-word;word-break;break-all;}    ```  ### CSS Hack大全    ``` html    \x3c!--[iflt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"><![endif]--\x3e IE7以下版本    \x3c!--[if IE 7]><html class="no-js lt-ie9 lt-ie8"><![endif]--\x3e IE7    \x3c!--[if IE 8]><html class="no-js lt-ie9"><![endif]--\x3e IE8    \x3c!--[ifgt IE 8]><html class="no-js"><![endif]--\x3e IE8以上    ```    ``` css    /* webkit and opera */    @media all and(min-width:0) {      .content.test {background: #0f0;}    }    /* webkit */    @media screen and(-webkit-min-device-pixel-ratio: 0) {      .content.test {background: #ff0;}    }    /*FireFox*/    @-moz-document url-prefix() {      .content.test {background: #f0f;}    }    /*IE6、IE7、IE8*/    @media\\0screen\\,screen\\9 {      .selector{property: value;}    }    /*IE9+*/    @media all and(min-width:0){      .content.test{background: #f009;}    }    /*IE10+*/    @media screen and(-ms-high-contrast: active),(-ms-high-contrast: none) {      .content.test {background: #0ff;}    }    ```'},{title:"【学习笔记】之echart",path:"/posts/echart.html",strippedContent:"## 使用  ### 方法一  ``` js  import Vue from 'vue'  import echarts from 'echarts'    Vue.prototype.$echarts = echarts  ```  ``` vue  <template>    <div ref=\"pieChart\"></div>  </template>  <script>  export default {    data () {      return {        myChart: null      }    },    methods: {      initChart () {        const that = this        this.myChart = this.$echarts.init(this.$refs.pieChart)        let option = {          ...        }        this.myChart.setOption(option)      }    }  }  <\/script>  ```  ### 方法二  ``` js  import Vue from 'vue'  // 安装 vue-echarts-v3  import IEcharts from 'vue-echarts-v3/src/lite.js'  // 安装 echarts  import 'echarts/lib/chart/bar'  import 'echarts/lib/chart/pie'    Vue.component('v-chart', IEcharts)  ```  ``` vue  <template>    <v-chart :option=\"option\" />  </template>  <script>  export default {    data () {      return {        option: {          ...        }      }    }  }  <\/script>  ```  ## 配置 option  ### title  标题组件，包含主标题和副标题  #### __title__.textStyle __| *__  ##### __title__.__textStyle__.rich __| Object__  在`rich`里面，可以自定义富文本样式。利用富文本样式，可以在标签中做出非常丰富的效果。    例如：  ``` js  label: {    // 在文本中，可以对部分文本采用 rich 中定义样式。    // 这里需要在文本中使用标记符号：    // `{styleName|text content text content}` 标记样式名。    // 注意，换行仍是使用 '\\n'。    formatter: [      '{a|这段文本采用样式a}',      '{b|这段文本采用样式b}这段用默认样式{x|这段用样式x}'    ].join('\\n'),      rich: {      a: {        color: 'red',        lineHeight: 10      },      b: {        backgroundColor: {          image: 'xxx/xxx.jpg'        },        height: 40,        align: 'center'      },      x: {        fontSize: 18,        fontFamily: 'Microsoft YaHei',        borderColor: '#449933',        borderRadius: 4      },      ...    }  }  ```  ### legend  图例组件  #### __legend__.type __| string__  图例的类型。可选值：  - `plain`：普通图例。缺省就是普通图例。  - `scroll`：可滚动翻页的图例。当图例数量较多时可以使用。  ### grid  直角坐标系内绘图网格，单个 grid 内最多可以放置上下两个 X 轴，左右两个 Y 轴。可以在网格上绘制折线图，柱状图，散点图（气泡图）。  #### __grid__.show __| boolean__  [ default: false ]    是否显示直角坐标系网格  #### __grid__.containLabel __| boolean__  [ default: false ]    grid 区域是否包含坐标轴的刻度标签，这常用于『防止标签溢出』的场景  ### xAxis  直角坐标系 grid 中的 x 轴  #### __xAxis__.type __| string__  [ default: 'category' ]    坐标轴类型。    可选：    - `value`: 数值轴，适用于连续数据。  - `category`: 类目轴，适用于离散的类目数据，为该类型时必须通过`data`设置类目数据。  - `time`: 时间轴，适用于连续的时序数据，与数值轴相比时间轴带有时间的格式化，在刻度计算上也有所不同，例如会根据跨度的范围来决定使用月，星期，日还是小时范围的刻度。  - `log`: 对数轴。适用于对数数据。  #### __xAxis__.data[i] __| Object__  类目数据，在类目轴（type: 'category'）中有效。    示例：  ``` js  // 所有类目名称列表  data: ['周一', '周二', '周三', '周四', '周五', '周六', '周日']  // 每一项也可以是具体的配置项，此时取配置项中的 `value` 为类目名  data: [{    value: '周一',    // 突出周一    textStyle: {      fontSize: 20,      color: 'red'    }  }, '周二', '周三', '周四', '周五', '周六', '周日']  ```  ### yAxis  直角坐标系 grid 中的 y 轴  ### polar  极坐标系，可以用于散点图和折线图  ### radiusAxis  极坐标系的径向轴  ### angleAxis  极坐标系的角度轴  ### radar  雷达图坐标系组件，只适用于雷达图  ### dataZoom[i]  用于区域缩放  ### visualMap[i]  视觉映射组件，用于进行『视觉编码』  ### tooltip  提示框组件，可以设置在多种地方：  全局 tooltip，坐标系 grid.tooltip、polar.tooltip、single.tooltip，系列 series.tooltip，每个数据项 series.data.tooltip  #### __tooltip__.trigger __| string__  [ default: 'item' ]    触发类型。    可选：  - `item`: 数据项图形触发，主要在散点图，饼图等无类目轴的图表中使用。  - `axis`: 坐标轴触发，主要在柱状图，折线图等会使用类目轴的图表中使用。  - `none`: 什么都不触发。  #### __tooltip__.triggerOn __| string__  [ default: 'mousemove|click' ]    提示框触发的条件，可选：  - `mousemove`: 鼠标移动时触发。  - `click`: 鼠标点击时触发。  - `mousemove|click`: 同时鼠标移动和点击时触发。  - `none`: 不在`mousemove`或`click`时触发，用户可以通过`action.tooltip.showTip`和`action.tooltip.hideTip`来手动触发和隐藏。也可以通过`axisPointer.handle`来触发或隐藏。  #### __tooltip__.formatter __| string, Function__  提示框浮层内容格式器，支持字符串模板和回调函数两种形式。  1. 字符串模板  - 折线（区域）图、柱状（条形）图、K线图: `{a}`（系列名称），`{b}`（类目值），`{c}`（数值）, `{d}`（无）  - 散点图（气泡）图: `{a}`（系列名称），`{b}`（数据名称），`{c}`（数值数组）, `{d}`（无）  - 地图: `{a}`（系列名称），`{b}`（区域名称），`{c}`（合并数值）, `{d}`（无）  - 饼图、仪表盘、漏斗图: `{a}`（系列名称），`{b}`（数据项名称），`{c}`（数值）, `{d}`（百分比）  ### axisPointer  这是坐标轴指示器（axisPointer）的全局公用设置，效果：鼠标悬浮到图上，可以出现标线和刻度文本  #### __axisPointer__.triggerOn __| string__  [ default: 'mousemove|click' ]    提示框触发的条件，可选：  - `mousemove`: 鼠标移动时触发。  - `click`: 鼠标点击时触发。  - `none`: 不在 'mousemove' 或 'click' 时触发。  ### toolbox  工具栏。内置有导出图片，数据视图，动态类型切换，数据区域缩放，重置五个工具  ### brush  区域选择组件，用户可以选择图中一部分数据，从而便于向用户展示被选中数据，或者他们的一些统计计算结果  ### geo  地理坐标系组件，用于地图的绘制，支持在地理坐标系上绘制散点图，线集  ### parallel  平行坐标系  ### parallelAxis  平行坐标系中的坐标轴  ### singleAxis  单轴。可以被应用到散点图中展现一维数据  ### timeline  提供了在多个 ECharts option 间进行切换、播放等操作的功能  ### graphic  原生图形元素组件。可以支持的图形元素包括：image, text, circle, sector, ring, polygon, polyline, rect, line, bezierCurve, arc, group  ### calendar  日历坐标系组件  ### dataset  数据集（dataset）组件用于单独的数据集声明，从而数据可以单独管理，被多个组件复用，并且可以自由指定数据到视觉的映射  ### aria  自动智能生成关于图表的描述  ### series[i]  系列列表。每个系列通过 type 决定自己的图表类型  #### series[i]-line  折线/面积图  ##### __series[i]-line__.emphasis __| Object__  图形的高亮样式。  ##### __series[i]-line__.data[i] __| Object__  系列中的数据内容数组。数组项通常为具体的数据项。    当需要对个别数据进行个性化定义时：  ``` js  [    12,    34,    {      value: 56,      //自定义标签样式，仅对该数据项有效      label: {},      //自定义特殊 itemStyle，仅对该数据项有效      itemStyle: {}    },    10  ]  ```  #### series[i]-bar  柱状/条形图  ##### __series[i]-bar__.barGap __| string__  [ default: 30% ]    不同系列的柱间距离，为百分比（如 '30%'，表示柱子宽度的 30%）。    如果想要两个系列的柱子重叠，可以设置 barGap 为 '-100%'。这在用柱子做背景的时候有用。  ##### __series[i]-bar__.barCategoryGap __| string__  [ default: '20%' ]    同一系列的柱间距离，默认为类目间距的20%，可设固定值  #### series[i]-pie  饼图  ##### __series[i]-pie__.center __| Array__  [ default: ['50%', '50%'] ]    调整饼图在容器中的位置，默认为容器中心，设置成百分比时第一项是相对于容器宽度，第二项是相对于容器高度。  ##### __series[i]-pie__.radius __| number, string, Array__  [ default: [0, '75%'] ]    饼图的半径。可以为如下类型：  - `number`: 直接指定外半径值。  - `string`: 例如，'20%'，表示外半径为容器高宽中较小一项的 20% 长度。  - `Array.<number|string>`: 数组的第一项是内半径，第二项是外半径。每一项遵从上述 number string 的描述。    可以将内半径设大显示成圆环图（Donut chart）。  ##### __series[i]-pie__.data[i] __| Object__  需要对个别内容指定进行个性化定义时：  ``` js  [{    name: '数据1',    value: 10  }, {    // 数据项名称    name: '数据2',    value : 56,    //自定义特殊 tooltip，仅对该数据项有效    tooltip:{},    //自定义特殊itemStyle，仅对该item有效    itemStyle:{}  }]  ```  ### color  调色盘颜色列表。如果系列没有设置颜色，则会依次循环从该列表中取颜色作为系列颜色。<br>  默认为：    ['#c23531', '#2f4554', '#61a0a8', '#d48265', '#91c7ae', '#749f83', '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3']  ### backgroundColor  背景色，默认无背景  ### textStyle  全局的字体样式  ### animation  是否开启动画  ### animationThreshold  是否开启动画的阈值，当单个系列显示的图形数量大于这个阈值时会关闭动画  ### animationDuration  初始动画的时长，支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的初始动画效果：  ``` js  animationDuration: function (idx) {    // 越往后的数据延迟越大    return idx * 100;  }  ```  ### animationEasing  初始动画的缓动效果  ### animationDelay  初始动画的延迟，支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的初始动画效果：  ``` js  animationDelay: function (idx) {    // 越往后的数据延迟越大    return idx * 100;  }  ```  ### animationDurationUpdate  数据更新动画的时长。<br>  支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的更新动画效果：  ``` js  animationDurationUpdate: function (idx) {    // 越往后的数据延迟越大    return idx * 100;  }  ```  ### animationEasingUpdate  数据更新动画的缓动效果  ### animationDelayUpdate  数据更新动画的延迟，支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的更新动画效果：  ``` js  animationDelayUpdate: function (idx) {    // 越往后的数据延迟越大    return idx * 100;  }  ```  ### blendMode  图形的混合模式，默认为`source-over`。 支持每个系列单独设置。<br>  `lighter`也是比较常见的一种混合模式，该模式下图形数量集中的区域会颜色叠加成高亮度的颜色（白色）。常常能起到突出该区域的效果。  ### hoverLayerThreshold  图形数量阈值，决定是否开启单独的 hover 层，在整个图表的图形数量大于该阈值时开启单独的 hover 层。<br>  单独的 hover 层主要是为了在高亮图形的时候不需要重绘整个图表，只需要把高亮的图形放入单独的一个 canvas 层进行绘制，防止在图形数量很多的时候因为高亮重绘所有图形导致卡顿。  ### useUTC  是否使用 UTC 时间。  - `true`: 表示`axis.type`为`time`时，依据 UTC 时间确定 tick 位置，并且`axisLabel`和`tooltip`默认展示的是 UTC 时间  - `false`: 表示`axis.type`为`time`时，依据本地时间确定 tick 位置，并且`axisLabel`和`tooltip`默认展示的是本地时间  ## API  ### echarts  全局 echarts 对象，在 script 标签引入 echarts.js 文件后获得，或者在 AMD 环境中通过 require('echarts') 获得。  ### echartsInstance  通过 `echarts.init` 创建的实例。  ### action  ECharts 中支持的图表行为，通过 dispatchAction 触发。  ### events  在 ECharts 中主要通过 on 方法添加事件处理函数。"},{title:"【学习笔记】之node",path:"/posts/node.html",strippedContent:"## NPM  ### npm命令  #### 初始化      npm init -y      自动生成`package.json`和`package-lock.json`文件，该文件保存依赖项信息并锁定依赖项版本  #### 安装依赖包      npm install 包名      npm i 包名  #### 删除依赖项      npm uninstall 包名      加上`--save`删除依赖项同时删除依赖信息  #### npm帮助      npm --help  #### 查看npm配置信息      npm config list  ### 使用淘宝服务器下载依赖  #### 方法一      npm install --global cnpm      cnpm install  #### 方法二      npm config set registry https://registry.npm.taobao.org      npm install  ## Node.js  ### Node.js REPL(交互式解释器)  #### 使用方法      $ node      > 1 + 4      5      > console.log(\"Hello World\")      Hello World      undefined  #### REPL 命令    - ctrl + c - 退出当前终端    - ctrl + c 按下两次 - 退出 Node REPL    - ctrl + d - 退出 Node REPL    - tab 键 - 列出当前命令    - .help - 列出使用命令    - .break - 退出多行表达式    - .clear - 退出多行表达式    - .save filename - 保存当前的 Node REPL 会话到指定文件    - .load filename - 载入当前 Node REPL 会话的文件内容。  ### 代码修改自动重启服务器      npm install --global nodemon      nodemon app.js  ### 回调函数  ``` js  function fn (callback) {    setTimeout(function () {      var data = 'hello wold'      callback(data)    }, 1000)  }  // 如果需要获取一个异步操作的结果，则必须通过回调函数来获取  fn (function (data) {    console.log(data)  })  ```  ### 模块加载  ``` js  // b.js  exports.foo = 'hello'  module.exports = 'hello'    // a.js  const b = require('./b')    console.log(b.foo) // 'hello'  console.log(b) // 'hello'  ```  > `require`加载优先从缓存区中加载<br>  > `require`在加载第三方包时会读取`node_modules`文件夹下的包名中的`package.json`中的`{'main': 'index.js'}`入口文件  ### fs模块    ``` js    const fs = require('fs')    // 该相对路径是执行 node 命令下的路径    fs.readFile('./assets/hello.txt', function (error, data) {      // data 为二进制      console.log(data.toString())    })    fs.writeFile('./assets/write.text', '### 你好，nodejs', function (error) {      console.log('文件写入成功')    })    ```  ### path模块    ``` js    const path = require('path')      path.parse('c:/a/b/index.js')    // {    //   root: 'c:/',    //   dir: 'c:/a/b',    //   base: 'index.js',    //   ext: '.js',    //   name: 'index'    // }      path.join('c:/a', 'b')    // 'c:\\\\a\\\\b'    ```  ### node 中的全局对象    #### __dirname    动态获取当前文件所属目录的绝对路径    > 在涉及文件操作的相对路径都是执行 node 命令下的路径，建议使用动态获取文件路径`path.join(__dirname, './文件.js')`    #### __filename    动态获取当前文件的绝对路径  ### url模块  ``` js  const url = require('url')    // 第二个参数 true，可以将请求参数转为对象 { name: 'chen', message: '黑马程序员' }  let obj = url.parse('https://www.bilibili.com/video/av27670326?name=chen&message=黑马程序员', true)    console.log(obj)  // obj = {  //   protocol: 'https:',  //   slashes: true,  //   auth: null,  //   host: 'www.bilibili.com',  //   port: null,  //   hostname: 'www.bilibili.com',  //   hash: null,  //   search: '?name=chen&message=黑马程序员',  //   query: [Object: null prototype] { name: 'chen', message: '黑马程序员' },  //   pathname: '/video/av27670326',  //   path: '/video/av27670326?name=chen&message=黑马程序员',  //   href:  //    'https://www.bilibili.com/video/av27670326?name=chen&message=黑马程序员'  // }  ```  ### 模板引擎  #### 安装      npm install art-template  #### 使用    ``` js    const template = require('art-template')      template.render(`<h1>${content}</h1>`, {      content: '你好！node.js'    })    ```  #### 语法    - 遍历    ``` html    <ul>      {{ each list }}      <li>索引 {{ $index + 1 }} ：{{ $value.name }}</li>      {{ /each }}    </ul>    ```    - 条件表达式    ``` html    {{ if admin }}      <p>admin</p>    {{ else if code > 0 }}      <p>master</p>    {{ else }}      <p>error!</p>    {{ /if }}    ```    - 调用子模板    ```    {{include './header.html'}}    ```    - 继承    ```    {{ extend './layout.html' }}    ```    - 插槽    ``` html    \x3c!-- layout.html --\x3e    {{ block 'body' }}    <h1>默认内容</h1>    {{ /block }}      \x3c!-- index.html --\x3e    {{ extend './layout.html' }}      {{ block 'body' }}    <div>      <a href=\"#\">替换内容</a>    </div>    {{ /block }}    ```  ### Node.js 连接 MongoDB  #### 开启数据库    打开控制台输入命令        $ mongod      `mongodb`默认数据存储在 C 盘中的 data => bin 文件夹下，所以需在 C 盘下启动  #### 安装      $ npm install mongoose  #### 连接    ``` js    const mongoose = require('mongoose')      // 连接数据库    mongoose.connect('mongodb://localhost/test', {useNewUrlParser: true})    ```  #### 创建    ``` js    // 设计数据模型    const userSchema = new mongoose.Schema({      username: {        type: String,        required: true      },      password: {        type: String,        required: true      },      email: {        type: String      }    })      // 发布数据模型    const User = mongoose.model('User', userSchema)    ```  #### 操作    ``` js    // 添加数据    let admin = new User({      username: 'chen',      password: 'cwb123',      email: 'chen@chen.com'    })    admin.save(function (err, ret) {      if (err) {        console.log(err)      } else {        console.log(ret)      }    })      // 查询数据    User.find({// 可选参数，搜索条件      username: 'chen'    }, function (err, ret) {      if (err) {        console.log(err)      } else {        console.log(ret)      }    })      // 删除数据    User.remove({      username: 'admin'    }, function (err, ret) {      if (err) {        console.log(err)      } else {        console.log('删除成功')      }    })      // 更新数据    User.update({      username: 'chen'    }, {      email: 'chen@qq.com'    }, function (err, ret) {      if (err) {        console.log(err)      } else {        console.log('更新成功')      }    })    ```  ### 创建 Node.js 应用  在  server.js 文件下  ``` js  // server.js  const http = require('http')    // request 请求对象：可获取客户端信息  // response 响应对象：给客户的发送响应消息  http.createServer(function (request, response) {    // 设置编码格式，解决中文乱码    response.setHeader('Content-Type', 'text/plain; charset=utf-8')      if (request.url === '/') {      let pro = {        name: '陈文彬',        age: 24      }      response.end(JSON.stringify(pro)) // 发送响应数据, 响应消息只能是字符串和二进制    } else {      response.end('404 not found!')    }  })    .listen(3000, function () {// 设置端口，启动服务器      console.log('请输入 http://127.0.0.1:3000/ 进行访问')    })  ```  使用 node 命令在终端执行以上的代码：  ```  $ nodemon server.js  请输入 http://127.0.0.1:3000/ 进行访问  ```  打开浏览器访问 http://127.0.0.1:3000/  ### 开放目录  ``` js  const fs = require('fs')  const http = require('http')    http.createServer(function (req, res) {    if (req.url.indexOf('/public/') === 0) {      fs.readFile('.' + req.url, function (err, data) {        if (err) {          return res.end('获取文件失败')        }        res.end(data)      })    }  })  ```  ### 模板引擎的使用    ``` js    http.createServer(function (req, res) {      fs.readFile('./views/index.html', function (err, data) {        if (err) {          return res.end(err.toString())        }        let htmlStr = template.render(data.toString(), {          content: content        })        res.end(htmlStr)      })    })    ```  ### 重定向  ``` js  response.statusCode = 302 // 状态码设置为 302 临时重定向  response.setHeader('Location', '/') // 设置重定向地址  response.end()  ```  ## Express  ### 创建 Node.js 应用    ``` js    const express = require('express')      const app = express()      app.get('/', function (req, res) {      res.send()    })      .listen(3000, function () {        console.log('请输入 http://127.0.0.1:3000/ 进行访问')      })    ```  ### 开放目录    浏览器收到 html 响应内容后从上到下依次解析，遇到获取静态资源如：link、script、img、iframe...等带有 src 和 href 属性标签的时候会自动发起新的请求，因此需要将这些静态资源文件开放    > a 标签需用户点击才出发请求    ``` html    \x3c!-- href 中的地址是客户端发起请求的地址，也就是服务端中 req.url --\x3e    <link href=\"/node_modules/bootstrap/dist/css/bootstrap.min.css\" rel=\"stylesheet\">    <link href=\"/public/css/main.css\" rel=\"stylesheet\">    ```    ``` js    // url地址 '/public/' 指向文件路径 './public/'    // 若 '/public/' 省略， 则 url 地址 '/' 指向文件路径 './public/'    app.use('/public/', express.static('./public/'))    app.use('/node_modules/', express.static('./node_modules/'))    ```  ### 模板引擎的使用  #### 安装      npm install art-template      npm install express-art-template  #### 配置    ``` js    // html 为查找文件的后缀名    app.engine('html', require('express-art-template'))    ```  #### 使用    ``` js    app.get('/', function (req, res) {      // html 文件默认在 views 文件夹下查找      res.render('index.html', {        content: content      })    })    ```  ### Get 和 Post 请求  #### Get    获取请求参数    ``` js    app.get('/post', function (req, res) {      // req.query === {}      console.log(req.query)    })    ```  #### Post    获取请求参数：<br>    express 不提供 post 请求的 api，需安装 body-parser 中间插件    ```    npm install body-parser    ```    ``` js    const bodyParser = require('body-parser')      // body-parser 的配置    app.use(bodyParser.urlencoded({ extended: false}))    app.use(bodyParser.json())      // POST 请求    app.post('/post', function (req, res) {      // req.body === {}      console.log(req.body)    })    ```  ### Router    ``` js    // router.js    const express = require('express')      // 创建路由容器    const router = express.Router()      // 把路由挂载到路由容器中    router.get('/', function(req, res) {      res.render('index.html')    })      module.exports = router    ```    ``` js    // app.js    const express = require('express')    const router = require('./router')      const app = express()      // 把路由容器挂载到 app 服务中    app.use(router)    ```  #### Ajax    当客户端`ajax`请求的数据类型设为`dataType: 'json'`时，服务端需返回`json`数据    ``` js    router.post('/login', function (req, res) {      res.status(200).json({        code: 0,        message: '登录成功'      })    })    ```  ### 重定向    ``` js    res.redirect('/')    ```  ### Session  #### 安装      npm install express-session  #### 使用    ``` js    const session = require('express-session')      // session 配置    app.use(session({      secret: 'keyboard cat', // 配置加密字符串      resave: false,      saveUninitialized: true    }))      app.get('/', function (req, res) {      req.session.user = {        name: 'chen',        age: 24      }      console.log(req.session.user)    })    ```"},{title:"Node+PM2项目部署",path:"/posts/deploy.html",strippedContent:"## Node开启服务器    ### 创建Node项目    1. 项目初始化        $ npm init -y        2. 安装 `express` 和 `compression`        $ npm install express      $ npm install compression        3. 在入口文件配置    ``` js    // app.js    const express = require('express')    const compression = require('compression')    const app = express()    // 一定要把这一行代码，写到 静态资源托管之前    app.use(compression())    app.use(express.static('./dist')) // 开放打包后的项目    app.listen(3000, () => {// 3000为端口      console.log('请输入 http://127.0.0.1:3000/ 进行访问')    })    ```  ### 开启HTTPS服务    配置HTTPS服务    ```js    const express = require('express')    const compression = require('compression')    const https = require('https')    const fs = require('fs')        const app = express()      //申请得到的cert和key文件    const options = {      cert: fs.readFileSync('./full_chain.pem'),      key: fs.readFileSync('./private.key')    }      // 一定要把这一行代码，写到 静态资源托管之前    app.use(compression())    app.use(express.static('./dist'))      https.createServer(opctions,app).listen(443);    ```    ## 使用PM2管理项目    1、 pm2需要全局安装            npm install -g pm2      2、进入项目根目录      2.1 启动进程/应用        pm2 start bin/www 或 pm2 start app.js      2.2 重命名进程/应用        pm2 start app.js --name wb123      2.3 添加进程/应用 watch          pm2 start bin/www --watch      2.4 结束进程/应用          pm2 stop www      2.5 结束所有进程/应用            pm2 stop all      2.6 删除进程/应用          pm2 delete www      2.7 删除所有进程/应用          pm2 delete all      2.8 列出所有进程/应用          pm2 list      2.9 查看某个进程/应用具体情况          pm2 describe www      2.10 查看进程/应用的资源消耗情况          pm2 monit      2.11 查看pm2的日志          pm2 logs      2.12 若要查看某个进程/应用的日志,使用          pm2 logs www      2.13 重新启动进程/应用          pm2 restart www      2.14 重新启动所有进程/应用          pm2 restart all"},{title:"【学习笔记】之vuex",path:"/posts/vuex.html",strippedContent:"## 安装  ### vuex    在 Vue 之后引入 vuex 会进行自动安装：    ``` html    <script src=\"/path/to/vue.js\"><\/script>    <script src=\"/path/to/vuex.js\"><\/script>    ```    **npm**    ``` sh    npm install vuex --save    ```    **yarn**    ``` sh    yarn add vuex    ```    在一个模块化的打包系统中，您必须显式地通过 Vue.use() 来安装 Vuex：    ``` js    import Vue from 'vue'    import Vuex from 'vuex'      Vue.use(Vuex)      const store = new Vuex.Store({      state: {        // ....      },      // ....    })      new Vue({      el: '#app',      store,      router,      components: { App },      template: '<App/>'    })    ```  ### 依赖    Vuex 依赖 Promise。如果你支持的浏览器并没有实现 Promise (比如 IE)，那么你可以使用一个 polyfill 的库，例如 es6-promise。      你可以通过 CDN 将其引入：    ``` html    <script src=\"https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.js\"><\/script>    ```    **npm** || **yarn**    ``` sh    npm install es6-promise --save # npm    yarn add es6-promise # Yarn    ```  ## 核心概念  ### State    作为一个唯一数据源而存在    ``` js    const store = new Vuex.Store({      state: {        count: 0      }    })    ```    ``` js    import { mapState } from 'vuex'    export default {      computed: {        ...mapState(['count']) // 将 `this.count` 映射为 `this.$store.state.count`      }    }    ```  ### Getter    当需要从 state 中派生出一些状态进行处理时使用 getter      例如对列表进行过滤并计数:    ``` js    const store = new Vuex.Store({      state: {        todos: [          { id: 1, text: '...', done: true },          { id: 2, text: '...', done: false }        ]      },      getters: {        // ...        getTodoById: (state) => (id) => {          return state.todos.find(todo => todo.id === id)        }      }    })    ```    ``` js    import { mapGetters } from 'vuex'    export default {      // ...      computed: {      // 使用对象展开运算符将 getter 混入 computed 对象中        ...mapGetters([          'getTodoById', // 将 `this.getTodoById(2)` 映射为 `this.$store.getters.getTodoById(2)`          // ...        ])      }    }    ```    > 注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。    ### Mutation    更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。**注意： mutation 必须是同步函数**    ``` js    // mutation-types.js    export const SOME_MUTATION = 'SOME_MUTATION' // 使用常量替代 mutation 事件类型, 在需要多人协作的大型项目中，这会很有帮助    ```    ``` js    import Vuex from 'vuex'    import { SOME_MUTATION } from './mutation-types'    const store = new Vuex.Store({      state: {        count: 1      },      mutations: {        [SOME_MUTATION] (state) {          // mutate state        },        incrementBy (state, payload) {          // 变更状态          state.count += payload.amount        }      }    })    ```    ``` js    import { mapMutations } from 'vuex'    export default {      // ...      methods: {        ...mapMutations([          'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`            // `mapMutations` 也支持载荷：          'incrementBy' // 将 `this.incrementBy({amount: 10})` 映射为 `this.$store.commit('incrementBy', {amount: 10})`        ]),        ...mapMutations({          add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`        })      }    }    ```  ### Action    Action 类似于 mutation，不同在于：    * Action 提交的是 mutation，而不是直接变更状态。    * Action 可以包含任意异步操作。    ``` js    const store = new Vuex.Store({      state: {        count: 0      },      mutations: {        increment (state) {          state.count++        }      },      actions: {        // Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象        increment (context) {          context.commit('increment')        },        incrementBy ({ commit, state }, amount) {          commit('increment')        }      }    })    ```    ``` js    import { mapActions } from 'vuex'    export default {      // ...      methods: {        ...mapActions([          'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`            // `mapActions` 也支持载荷：          'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`        ]),        ...mapActions({          add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`        })      }    }    ```  ### Module    为了解决 store 对象变得臃肿，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：    ``` js    const moduleA = {      state: { count: 0 },      mutations: { ... },      actions: {         incrementIfOddOnRootSum ({ state, commit, rootState, rootGetters }) {          // 这里的 `state` 对象是模块的局部状态， `rootState` 对象是模块的根节点状态          if ((state.count + rootState.count) % 2 === 1) {            commit('increment')          }        }      },      getters: {        // 模块内部的 getter，根节点状态会作为第三个参数暴露出来        sumWithRootCount (state, getters, rootState) {          return state.count + rootState.count        }      }    }      const moduleB = {      state: { ... },      mutations: { ... },      actions: { ... }    }      const store = new Vuex.Store({      state: { count: 10 },      mutations: { ... },      actions: { ... },      modules: {        a: moduleA,        b: moduleB      }    })    ```    ``` js    import { mapState, mapActions } from 'vuex'    export default {      computed: {        ...mapState('some/nested/module', {          a: state => state.a, // -> this.$store.state.a          b: state => state.b // -> this.$store.state.b        })      },      methods: {        ...mapActions('some/nested/module', [          'foo', // -> this.foo()          'bar' // -> this.bar()        ])      }    }    ```  ## 项目结构    需要遵守的规则:     1. 应用层级的状态应该集中到单个 store 对象中。    2. 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。    3. 异步逻辑都应该封装到 action 里面。    ``` sh    ├── index.html    ├── main.js    ├── api    │   └── ... # 抽取出API请求    ├── components    │   ├── App.vue    │   └── ...    └── store        ├── index.js          # 我们组装模块并导出 store 的地方        ├── actions.js        # 根级别的 action        ├── mutations.js      # 根级别的 mutation        └── modules            ├── cart.js       # 购物车模块            └── products.js   # 产品模块    ```  ### 严格模式    开启严格模式，仅需在创建 store 的时候传入 strict: true：    ``` js    const store = new Vuex.Store({      // ...      strict: true    })    ```    在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到      **不要在发布环境下启用严格模式！** 严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。        使用构建工具来处理这种情况：    ``` js    const store = new Vuex.Store({      // ...      strict: process.env.NODE_ENV !== 'production'    })    ```  ## 表单处理    当在严格模式中使用 Vuex 时，在属于 Vuex 的 state 上使用 v-model 会抛出一个错误。    ``` html    <input v-model=\"message\">    ```    ``` js    // ...    computed: {      message: {        get () {          return this.$store.state.obj.message        },        set (value) {          this.$store.commit('updateMessage', value)        }      }    }    ```  "},{title:"【学习笔记】之router",path:"/posts/vueRouter.html",strippedContent:"### 起步    ``` html    \x3c!-- 使用 router-link 组件来导航，通过传入 `to` 属性指定链接，<router-link> 默认会被渲染成一个 `<a>` 标签 --\x3e    <router-link to=\"/foo\">Go to Foo</router-link>    <router-link to=\"/bar\">Go to Bar</router-link>    \x3c!-- 路由出口，路由匹配到的组件将渲染在这里 --\x3e    <router-view></router-view>    ```    ``` js    // 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)    // 1. 定义 (路由) 组件。    // 可以从其他文件 import 进来    const Foo = { template: '<div>foo</div>' }    const Bar = { template: '<div>bar</div>' }    // 2. 定义路由    // 每个路由应该映射一个组件。 其中\"component\" 可以是通过 Vue.extend() 创建的组件构造器，或者，只是一个组件配置对象。    const routes = [      { path: '/foo', component: Foo },      { path: '/bar', component: Bar }    ]    // 3. 创建 router 实例，然后传 `routes` 配置，还可以传别的配置参数。    const router = new VueRouter({      routes // (缩写) 相当于 routes: routes    })    // 4. 创建和挂载根实例。    const app = new Vue({      router    }).$mount('#app')    ```    > 通过注入路由器，我们可以在任何组件内通过 this.$router 访问路由器，也可以通过 this.$route 访问当前路由  ### 动态路由匹配    ``` js    const router = new VueRouter({      routes: [        // 动态路径参数 以冒号开头        {          path: '/user/:id',          component: {            template: '<div>User {{ $route.params.id }}</div>',            watch: {              '$route' (to, from) {                // 对路由变化作出响应...              }            },            beforeRouteUpdate (to, from, next) {              // react to route changes...              // don't forget to call next()            }          }        }      ]    })    ```  ### 嵌套路由    ``` js    const router = new VueRouter({      routes: [        { path: '/user/:id',          component: {            template: `              <div class=\"user\">                <h2>User {{ $route.params.id }}</h2>                <router-view></router-view>              </div>            `          },          children: [            {              // 当 /user/:id/profile 匹配成功，              // UserProfile 会被渲染在 User 的 <router-view> 中              path: 'profile',              component: UserProfile            },            {              // 当 /user/:id/posts 匹配成功              // UserPosts 会被渲染在 User 的 <router-view> 中              path: 'posts',              component: UserPosts            }          ]        }      ]    })    ```  ### 编程式的导航    > 注意：在 Vue 实例内部，你可以通过 $router 访问路由实例。因此你可以调用 this.$router.push。    * router.push(location, onComplete?, onAbort?)<br>    想要导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。    ``` js    const router = new VueRouter({      routes: [        {          path: '/user/:userId',          name: 'user',          component: User        }      ]    })    // 命名的路由， 变成 /user/123    router.push({ name: 'user', params: { userId: '123' }})    // 带查询参数，变成 /register?plan=private    router.push({ path: 'register', query: { plan: 'private' }})    ```    * router.replace(location, onComplete?, onAbort?)<br>    跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。    * router.go(n)<br>    这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。    ``` js    // 在浏览器记录中前进一步，等同于 history.forward()    router.go(1)    // 后退一步记录，等同于 history.back()    router.go(-1)    ```  ### 命名视图    ``` html    \x3c!-- 如果 router-view 没有设置名字，那么默认为 default。 --\x3e    <router-view class=\"view one\"></router-view>    <router-view class=\"view two\" name=\"a\"></router-view>    <router-view class=\"view three\" name=\"b\"></router-view>    ```    ``` js    // 一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置 (带上 s)    const router = new VueRouter({      routes: [        {          path: '/',          components: {            default: { template: '<div>foo</div>' },            a: { template: '<div>Bar</div>' },            b: { template: '<div>Baz</div>' }          }        }      ]    })    ```  ### 重定向和别名  #### 重定向    “重定向”的意思是，当用户访问 /a时，URL 将会被替换成 /b，然后匹配路由为 /b    ``` js    const router = new VueRouter({      routes: [        { path: '/a', redirect: '/b' },        { path: '/a', redirect: { name: 'foo' }},        { path: '/a', redirect: to => {          // 方法接收 目标路由 作为参数          // return 重定向的 字符串路径/路径对象        }}      ]    })    ```  #### 别名    /a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。    ``` js    const router = new VueRouter({      routes: [        { path: '/a', component: A, alias: '/b' }      ]    })    // “别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。    ```  ### 路由组件传参    ``` js    // 使用 props 将组件和路由解耦：    const User = {      props: ['id'],      template: '<div>User {{ id }}</div>'    }    const router = new VueRouter({      routes: [        { path: '/user/:id', component: User, props: true },        // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：        {          path: '/user/:id',          components: { default: User, sidebar: Sidebar },          props: { default: true, sidebar: false }        },        // URL /search?q=vue 会将 {query: 'vue'} 作为属性传递给 SearchUser 组件        { path: '/search', component: SearchUser, props: (route) => ({ query: route.query.q }) }      ]    })    ```  ### HTML5 History 模式    ``` js    const router = new VueRouter({      mode: 'history',      routes: [...]    })    ```  ### 导航守卫  #### router.beforeEach 全局前置守卫    ``` js    const router = new VueRouter({ ... })    router.beforeEach((to, from, next) => {      // .....    })    ```    > 当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中。    * to: Route: 即将要进入的目标 路由对象    * from: Route: 当前导航正要离开的路由    * next: Function: 确保要调用 next 方法，否则钩子就不会被 resolved，如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。      * next(): 进行管道中的下一个钩子。      * next(false): 中断当前的导航。      * next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。      * next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。  #### router.beforeResolve 全局解析守卫    > 这和 router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。  ### router.afterEach 全局后置钩子    ``` js    router.afterEach((to, from) => {      // ...    })    ```  #### beforeEnter 路由独享的守卫    ``` js    // 这些守卫与全局前置守卫的方法参数是一样的。    const router = new VueRouter({      routes: [        {          path: '/foo',          component: Foo,          beforeEnter: (to, from, next) => {            // ...          }        }      ]    })    ```  #### 组件内的守卫    * beforeRouteEnter    * beforeRouteUpdate (2.2 新增)    * beforeRouteLeave    ``` js    const Foo = {      template: `...`,      beforeRouteEnter (to, from, next) {        // 在渲染该组件的对应路由被 confirm 前调用        // 不！能！获取组件实例 `this`，因为当守卫执行前，组件实例还没被创建        next(vm => {          // 通过 `vm` 访问组件实例        })      },      beforeRouteUpdate (to, from, next) {        // 在当前路由改变，但是该组件被复用时调用        // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。        // 可以访问组件实例 `this`      },      beforeRouteLeave (to, from, next) {        // 导航离开该组件的对应路由时调用        // 可以访问组件实例 `this`      }    }    ```  #### 完整的导航解析流程    1. 导航被触发    2. 在失活的组件里调用离开守卫    3. 调用全局的 beforeEach 守卫    4. 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)    5. 在路由配置里调用 beforeEnter    6. 解析异步路由组件    7. 在被激活的组件里调用 beforeRouteEnter    8. 调用全局的 beforeResolve 守卫 (2.5+)    9. 导航被确认    10. 调用全局的 afterEach 钩子    11. 触发 DOM 更新    12. 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数  ### 路由元信息    ``` js    // 配置 mate 字段    const router = new VueRouter({      routes: [        {          path: '/foo',          component: Foo,          children: [            {              path: 'bar',              component: Bar,              // a meta field              meta: { requiresAuth: true }            }          ]        }      ]    })    // 访问这个 meta 字段    router.beforeEach((to, from, next) => {      if (to.matched.some(record => record.meta.requiresAuth)) {        // this route requires auth, check if logged in        // if not, redirect to login page.        if (!auth.loggedIn()) {          next({            path: '/login',            query: { redirect: to.fullPath }          })        } else {          next()        }      } else {        next() // 确保一定要调用 next()      }    })    ```  ### 过渡动效    ``` js    // 单个路由的过渡    const Foo = {      template: `        <transition name=\"slide\">          <div class=\"foo\">...</div>        </transition>      `    }    // 基于路由的动态过渡    <transition :name=\"transitionName\">      <router-view></router-view>    </transition>    ```  ### 滚动行为    > 注意: 这个功能只在支持 history.pushState 的浏览器中可用    ``` js    // scrollBehavior 方法接收 to 和 from 路由对象。第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用，返回滚动位置的对象信息    const router = new VueRouter({      routes: [...],      scrollBehavior (to, from, savedPosition) {        // 对于所有路由导航，简单地让页面滚动到顶部        if (savedPosition) {          return savedPosition        } else {          return { x: 0, y: 0 }        }      }    })    ```  ### 路由懒加载    > 当路由被访问的时候才加载对应组件，更加高效。如果您使用的是 Babel，你将需要添加 [syntax-dynamic-import](https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import/) 插件，才能使 Babel 可以正确地解析语法。    ``` js    // 定义一个能够被 Webpack 自动代码分割的异步组件，把组件按组分块    const Foo = () => import(/* webpackChunkName: \"group-foo\" */ './Foo.vue')    const Bar = () => import(/* webpackChunkName: \"group-foo\" */ './Bar.vue')    const Baz = () => import(/* webpackChunkName: \"group-foo\" */ './Baz.vue')    ```"},{title:"【学习笔记】之html",path:"/posts/html.html",strippedContent:'### 初始化    ``` html    <!DOCTYPE html>    <html lang="zh-CN">    <head>      <meta http-equiv="content-type" content="text/html; charset=UTF-8" />      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">      <meta http-equiv="Cache-Control" content="no-cache, must-revalidate">      <meta http-equiv="pragma" content="no-cache">      <meta http-equiv="expires" content="0">      <meta name="renderer" content="webkit">      <title></title>      \x3c!-- CSS --\x3e      <link rel="stylesheet" type="text/css" href="css/init.css">        \x3c!-- JS --\x3e        <script type="text/javascript" src="js/jquery.min.js"><\/script>    </head>      <body>              </body>    </html>    ```  ### 移动端页面开发常用标签    ``` html    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />    \x3c!--     device-width - 设备的宽度    initial-scale - 初始的缩放比例      minimum-scale - 允许用户缩放到的最小比例       maximum-scale - 允许用户缩放到的最大比例      user-scalable - 用户是否可以手动缩放     --\x3e    <meta content="telephone=no,email=no" name="format-detection">    \x3c!-- 禁止自动识别电话号码和邮箱 --\x3e    <meta content="yes" name="apple-mobile-web-app-capable">    \x3c!-- 苹果手机：会删除默认的工具栏和菜单栏，网站开启对web app程序的支持 --\x3e    <meta name="apple-mobile-web-app-status-bar-style" content="black" />    \x3c!-- 苹果手机：在web app应用下状态条（屏幕顶部条）的颜色,默认值为default（白色），可以定为black（黑色）和black-translucent（灰色半透明）。 --\x3e    <meta name="apple-touch-fullscreen" content="yes" />    \x3c!-- 苹果手机：如果把一个web app添加到了主屏幕中，那么从主屏幕中打开这个web app则全屏显示 --\x3e    <link rel="apple-touch-icon" href="/static/images/identity/HTML5_Badge_64.png" />    \x3c!-- 苹果手机：将应用添加到手机主屏幕，会有一个icon可以直接进入 --\x3e    ```  ### flash代码    ``` html    <embed src="swf/f1.swf" width="130" height="450" quality="high"wmode="transparent" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash" type="application/x-shockwave-flash">    <object id="FlashID"classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="350" height="109">    <param name="movie" value="images/logo.swf">    <param name="quality" value="high">    <param name="wmode" value="transparent">    <param name="swfversion" value="11.2.0.0">    \x3c!--此 param 标签提示使用FlashPlayer6.0 r65 和更高版本的用户下载最新版本的FlashPlayer。如果您不想让用户看到该提示，请将其删除。--\x3e    <param name="expressinstall" value="/images/expressInstall.swf">    \x3c!--下一个对象标签用于非 IE 浏览器。所以使用 IECC 将其从 IE 隐藏。--\x3e    \x3c!--[if!IE]>--\x3e    <object type="application/x-shockwave-flash" data="images/logo.swf" width="350" height="109">    \x3c!--<![endif]--\x3e    <param name="quality" value="high">    <param name="wmode" value="transparent">    <param name="swfversion" value="11.2.0.0">    <param name="expressinstall" value="/images/expressInstall.swf">    \x3c!--浏览器将以下替代内容显示给使用FlashPlayer6.0和更低版本的用户。--\x3e    <div>      <p><imgsrc="images/logo.png"></p>    </div>    \x3c!--[if!IE]>--\x3e    </object>    \x3c!--<![endif]--\x3e    </object>    ```  ### iframe    ``` html    <iframe frameBorder="0" width="100%" height="100%" marginHeight="0" marginWidth="0" scrolling="no" allowtransparency="true" src="foot.html"></iframe>    ```'},{title:"【学习笔记】之jQuery",path:"/posts/jQuery.html",strippedContent:'### 点击选中    ``` js    $(function() {      $(".eui-btn a").click(function() {        if ($(this).hasClass("active")) {          $(this).removeClass("active");        } else {          $(this).addClass("active");        }      });    });    ```  ### 滚动更换头部    ``` js    $(window).on(\'scroll\', function() {      if ($(window).scrollTop() > 30) {        $(\'.eui-header\').addClass(\'on\');      } else {        $(\'.eui-header\').removeClass(\'on\');      }    });    ```  ### 滚动视觉差    ``` js    $("#goTop").click(function() {      $(\'html, body\').animate({scrollTop: 0}, 300);      return false;    })    ```  ### 手风琴切换js    ``` js    $(function() {      $(".am-menu-nav li").click(function() {        if ($(this).children("div").is(":hidden")) {          $(this).children("div").stop(false,true).slideDown();          $(this).siblings("li").children("div").stop(false, true).slideUp();        } else {          $(this).children("div").stop(false, true).slideUp();        }      });    });    ```  ### 点击右侧导航页面平滑滚动至相应位置    ``` html    <div id="menu"class="smart-city-nav">      <a href="#item1"><span>智慧城市</span></a>      <a href="#item2"><span>智慧应急</span></a>      <a href="#item3"><span>智慧政务</span></a>      <a href="#item4"><span>智慧云</span></a>      <a href="#item5"><span>城市运营</span></a>      <a href="#item6"><span>云服务</span></a>    </div>    <div class="eui-main">      <div class="item" id="item1"></div>      <div class="item" id="item2"></div>      <div class="item" id="item3"></div>      <div class="item" id="item4"></div>      <div class="item" id="item5"></div>      <div class="item" id="item6"></div>    </div>    ```    ``` js    $(document).ready(function() {      $(window).scroll(function() {        var top = $(document).scrollTop(); // 定义变量，获取滚动条的高度        var menu = $("#menu"); // 定义变量，获取侧边导航id        var items = $(".eui-main").find(".item"); // 定义变量，查找.item        varcurId="";        vartopVal = $(this).scrollTop();        if (topVal > 200) {          menu.fadeIn(150);        } else {          menu.fadeOut(150);        }        // 定义变量，当前所在的楼层item #id         items.each(function() {          var m = $(this); // 定义变量，获取当前类          varitemsTop = m.offset().top; // 定义变量，获取当前类的top偏移量          if (top > itemsTop-200) {            curId ="#" + m.attr("id");          } else {            return false;          }        });        //给相应的楼层设置active,取消其他楼层的active        varcurLink = menu.find(".active");          if (curId && curLink.attr("href") != curId) {            curLink.removeClass("active");            menu.find("[href=" + curId + "]").addClass("active");          }          // console.log(top);      });      $("#menu a").click(function() {        varhref = $(this).attr("href");        var pos = $(href).offset().top;        $("html,body").animate({scrollTop: pos},500);        return false;      });    });    ```  ### jQuery打开页面数字数值滚动代码    ``` html    <script type="text/javascript"src="js/jquery.min.js"><\/script>    <script type="text/javascript"src="js/numroll.js"><\/script>    ....    <span class="timer" data-to="300000" data-speed="2000">300000</span>    ```    ``` js    $(\'.timer\').each(count)    ```  ### H5视频播放暂停    ``` js    varmyVideo = document.getElementById("eveVideo");    $(".play-pause").click(function() {      if (myVideo.paused) {        myVideo.play();        $(this).removeClass("on");        } else {        myVideo.pause();        $(this).addClass("on");      }    });    ```  ### 鼠标经过显示span文字为title    ``` js    $(".eui-activity-btn a").hover(function() {      var tit = $(this).find("span").text();      $(this).attr("title", tit);    });    ```  ### 鼠标经过淡入淡出显示隐藏效果    ``` js    $(".show-hide").hover(function() {      $(this).find(".sub").fadeIn(150);    }, function() {      $(this).find(".sub").fadeOut(150);    });    ```  ### 百度分享    ``` html    <div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more">分享</a></div>    ```    ``` js    window._bd_share_config = {      "common": {        "bdSnsKey": {},        "bdText": "",        "bdMini":"2",        "bdMiniList": false,        "bdPic": "",        "bdStyle": "1",        "bdSize": "24"      }, "share": {}    };    with(document)0[(getElementsByTagName(\'head\')[0]||body).appendChild(createElement(\'script\')).src=\'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=\'+~(-newDate()/36e5)];    ```'}]}}]);